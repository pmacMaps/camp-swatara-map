function t(t,i,e,s){Object.defineProperty(t,i,{get:e,set:s,enumerable:!0,configurable:!0})}var i=("undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{}).parcelRequire594f;i.register("bPFMP",(function(e,s){t(e.exports,"loadLibtess",(function(){return l})),t(e.exports,"triangulate",(function(){return y}));var n=i("cQaZU"),h=i("5HTPH");let r=null,x=null;async function l(){return r||(r=async function(){const t=(0,h.default)("esri-csp-restrictions")?await i("6me6H").then((t=>t.l)):await i("3eH1a").then((t=>t.l));x=await t.load({locateFile:t=>(0,n.getAssetUrl)(`esri/core/libs/libtess/${t}`)})}()),r}function y(t,i){const e=Math.max(t.length,128e3);return x.triangulate(t,i,e)}})),i.register("6me6H",(function(t,e){t.exports=import("./"+i("kyEFX").resolve("98i3f")).then((()=>i("jrNQo")))})),i.register("kyEFX",(function(i,e){var s,n;t(i.exports,"register",(function(){return s}),(function(t){return s=t})),t(i.exports,"resolve",(function(){return n}),(function(t){return n=t}));var h={};s=function(t){for(var i=Object.keys(t),e=0;e<i.length;e++)h[i[e]]=t[i[e]]},n=function(t){var i=h[t];if(null==i)throw new Error("Could not resolve bundle with id "+t);return i}})),i.register("3eH1a",(function(t,e){t.exports=import("./"+i("kyEFX").resolve("bZNOJ")).then((()=>i("drxWa")))})),i.register("c86nJ",(function(e,s){t(e.exports,"TileClipper",(function(){return o})),t(e.exports,"SimpleBuilder",(function(){return a}));var n,h,r=i("aPQ4T"),x=i("tIMRF"),l=i("c4cvq");class y{constructor(t,i,e){this.ratio=t,this.x=i,this.y=e}}class o{setPixelMargin(t){t!==this.pixelMargin&&(this.pixelMargin=t,this.setExtent(this._extent))}setExtent(t){this._extent=t,this.finalRatio=this.tileSize/t*(1<<this.dz);let i=this.pixelRatio*this.pixelMargin;i/=this.finalRatio;const e=t>>this.dz;i>e&&(i=e),this.margin=i,this.xmin=e*this.xPos-i,this.ymin=e*this.yPos-i,this.xmax=this.xmin+e+2*i,this.ymax=this.ymin+e+2*i}reset(t){this.type=t,this.lines=[],this.starts=[],this.line=null,this.start=0}moveTo(t,i){this._pushLine(),this._prevIsIn=this._isIn(t,i),this._moveTo(t,i,this._prevIsIn),this._prevPt=new(0,x.Point)(t,i),this._firstPt=new(0,x.Point)(t,i),this._dist=0}lineTo(t,i){const e=this._isIn(t,i),s=new(0,x.Point)(t,i),n=x.Point.distance(this._prevPt,s);let h,r,l,o,a,u,c,p;if(e)this._prevIsIn?this._lineTo(t,i,!0):(h=this._prevPt,r=s,l=this._intersect(r,h),this.start=this._dist+n*(1-this._r),this._lineTo(l.x,l.y,!0),this._lineTo(r.x,r.y,!0));else if(this._prevIsIn)r=this._prevPt,h=s,l=this._intersect(r,h),this._lineTo(l.x,l.y,!0),this._lineTo(h.x,h.y,!1);else{const t=this._prevPt,i=s;if(t.x<=this.xmin&&i.x<=this.xmin||t.x>=this.xmax&&i.x>=this.xmax||t.y<=this.ymin&&i.y<=this.ymin||t.y>=this.ymax&&i.y>=this.ymax)this._lineTo(i.x,i.y,!1);else{const e=[];if((t.x<this.xmin&&i.x>this.xmin||t.x>this.xmin&&i.x<this.xmin)&&(o=(this.xmin-t.x)/(i.x-t.x),p=t.y+o*(i.y-t.y),p<=this.ymin?u=!1:p>=this.ymax?u=!0:e.push(new y(o,this.xmin,p))),(t.x<this.xmax&&i.x>this.xmax||t.x>this.xmax&&i.x<this.xmax)&&(o=(this.xmax-t.x)/(i.x-t.x),p=t.y+o*(i.y-t.y),p<=this.ymin?u=!1:p>=this.ymax?u=!0:e.push(new y(o,this.xmax,p))),(t.y<this.ymin&&i.y>this.ymin||t.y>this.ymin&&i.y<this.ymin)&&(o=(this.ymin-t.y)/(i.y-t.y),c=t.x+o*(i.x-t.x),c<=this.xmin?a=!1:c>=this.xmax?a=!0:e.push(new y(o,c,this.ymin))),(t.y<this.ymax&&i.y>this.ymax||t.y>this.ymax&&i.y<this.ymax)&&(o=(this.ymax-t.y)/(i.y-t.y),c=t.x+o*(i.x-t.x),c<=this.xmin?a=!1:c>=this.xmax?a=!0:e.push(new y(o,c,this.ymax))),0===e.length)a?u?this._lineTo(this.xmax,this.ymax,!0):this._lineTo(this.xmax,this.ymin,!0):u?this._lineTo(this.xmin,this.ymax,!0):this._lineTo(this.xmin,this.ymin,!0);else if(e.length>1&&e[0].ratio>e[1].ratio)this.start=this._dist+n*e[1].ratio,this._lineTo(e[1].x,e[1].y,!0),this._lineTo(e[0].x,e[0].y,!0);else{this.start=this._dist+n*e[0].ratio;for(let t=0;t<e.length;t++)this._lineTo(e[t].x,e[t].y,!0)}this._lineTo(i.x,i.y,!1)}}this._dist+=n,this._prevIsIn=e,this._prevPt=s}close(){if(this.line.length>2){const t=this._firstPt,i=this._prevPt;t.x===i.x&&t.y===i.y||this.lineTo(t.x,t.y);const e=this.line;let s=e.length;for(;s>=4&&(e[0].x===e[1].x&&e[0].x===e[s-2].x||e[0].y===e[1].y&&e[0].y===e[s-2].y);)e.pop(),e[0].x=e[s-2].x,e[0].y=e[s-2].y,--s}}result(t=!0){return this._pushLine(),0===this.lines.length?null:(this.type===x.GeometryType.Polygon&&t&&u.simplify(this.tileSize,this.margin*this.finalRatio,this.lines),this.lines)}resultWithStarts(){if(this.type!==x.GeometryType.LineString)throw new Error("Only valid for lines");this._pushLine();const t=this.lines,i=t.length;if(0===i)return null;const e=[];for(let s=0;s<i;s++)e.push({line:t[s],start:this.starts[s]||0});return e}_isIn(t,i){return t>=this.xmin&&t<=this.xmax&&i>=this.ymin&&i<=this.ymax}_intersect(t,i){let e,s,n;if(i.x>=this.xmin&&i.x<=this.xmax)s=i.y<=this.ymin?this.ymin:this.ymax,n=(s-t.y)/(i.y-t.y),e=t.x+n*(i.x-t.x);else if(i.y>=this.ymin&&i.y<=this.ymax)e=i.x<=this.xmin?this.xmin:this.xmax,n=(e-t.x)/(i.x-t.x),s=t.y+n*(i.y-t.y);else{s=i.y<=this.ymin?this.ymin:this.ymax,e=i.x<=this.xmin?this.xmin:this.xmax;const h=(e-t.x)/(i.x-t.x),r=(s-t.y)/(i.y-t.y);h<r?(n=h,s=t.y+h*(i.y-t.y)):(n=r,e=t.x+r*(i.x-t.x))}return this._r=n,new(0,x.Point)(e,s)}_pushLine(){this.line&&(this.type===x.GeometryType.Point?this.line.length>0&&(this.lines.push(this.line),this.starts.push(this.start)):this.type===x.GeometryType.LineString?this.line.length>1&&(this.lines.push(this.line),this.starts.push(this.start)):this.type===x.GeometryType.Polygon&&this.line.length>3&&(this.lines.push(this.line),this.starts.push(this.start))),this.line=[],this.start=0}_moveTo(t,i,e){this.type!==x.GeometryType.Polygon?e&&(t=Math.round((t-(this.xmin+this.margin))*this.finalRatio),i=Math.round((i-(this.ymin+this.margin))*this.finalRatio),this.line.push(new(0,x.Point)(t,i))):(e||(t<this.xmin&&(t=this.xmin),t>this.xmax&&(t=this.xmax),i<this.ymin&&(i=this.ymin),i>this.ymax&&(i=this.ymax)),t=Math.round((t-(this.xmin+this.margin))*this.finalRatio),i=Math.round((i-(this.ymin+this.margin))*this.finalRatio),this.line.push(new(0,x.Point)(t,i)),this._is_h=!1,this._is_v=!1)}_lineTo(t,i,e){let s,n;if(this.type!==x.GeometryType.Polygon)if(e){if(t=Math.round((t-(this.xmin+this.margin))*this.finalRatio),i=Math.round((i-(this.ymin+this.margin))*this.finalRatio),this.line.length>0&&(s=this.line[this.line.length-1],s.equals(t,i)))return;this.line.push(new(0,x.Point)(t,i))}else this.line&&this.line.length>0&&this._pushLine();else if(e||(t<this.xmin&&(t=this.xmin),t>this.xmax&&(t=this.xmax),i<this.ymin&&(i=this.ymin),i>this.ymax&&(i=this.ymax)),t=Math.round((t-(this.xmin+this.margin))*this.finalRatio),i=Math.round((i-(this.ymin+this.margin))*this.finalRatio),this.line&&this.line.length>0){s=this.line[this.line.length-1];const e=s.x===t,h=s.y===i;if(e&&h)return;this._is_h&&e||this._is_v&&h?(s.x=t,s.y=i,n=this.line[this.line.length-2],n.x===t&&n.y===i?(this.line.pop(),this.line.length<=1?(this._is_h=!1,this._is_v=!1):(n=this.line[this.line.length-2],this._is_h=n.x===t,this._is_v=n.y===i)):(this._is_h=n.x===t,this._is_v=n.y===i)):(this.line.push(new(0,x.Point)(t,i)),this._is_h=e,this._is_v=h)}else this.line.push(new(0,x.Point)(t,i))}constructor(t,i,e,s=8,n=8){this.lines=[],this.starts=[],this.validateTessellation=!0,this.pixelRatio=s,this.pixelMargin=n,this.tileSize=r.TILE_SIZE*s,this.dz=t,this.yPos=i,this.xPos=e}}class a{setExtent(t){this._ratio=4096===t?1:4096/t}get validateTessellation(){return this._ratio<1}reset(t){this.lines=[],this.line=null}moveTo(t,i){this.line&&this.lines.push(this.line),this.line=[];const e=this._ratio;this.line.push(new(0,x.Point)(t*e,i*e))}lineTo(t,i){const e=this._ratio;this.line.push(new(0,x.Point)(t*e,i*e))}close(){const t=this.line;t&&!t[0].isEqual(t[t.length-1])&&t.push(t[0])}result(){return this.line&&this.lines.push(this.line),0===this.lines.length?null:this.lines}}(h=n||(n={}))[h.sideLeft=0]="sideLeft",h[h.sideRight=1]="sideRight",h[h.sideTop=2]="sideTop",h[h.sideBottom=3]="sideBottom";class u{static simplify(t,i,e){if(!e)return;const s=-i,h=t+i,r=-i,x=t+i,l=[],y=[],o=e.length;for(let t=0;t<o;++t){const i=e[t];if(!i||i.length<2)continue;let o,a=i[0];const u=i.length;for(let e=1;e<u;++e)o=i[e],a.x===o.x&&(a.x<=s&&(a.y>o.y?(l.push(t),l.push(e),l.push(n.sideLeft),l.push(-1)):(y.push(t),y.push(e),y.push(n.sideLeft),y.push(-1))),a.x>=h&&(a.y<o.y?(l.push(t),l.push(e),l.push(n.sideRight),l.push(-1)):(y.push(t),y.push(e),y.push(n.sideRight),y.push(-1)))),a.y===o.y&&(a.y<=r&&(a.x<o.x?(l.push(t),l.push(e),l.push(n.sideTop),l.push(-1)):(y.push(t),y.push(e),y.push(n.sideTop),y.push(-1))),a.y>=x&&(a.x>o.x?(l.push(t),l.push(e),l.push(n.sideBottom),l.push(-1)):(y.push(t),y.push(e),y.push(n.sideBottom),y.push(-1)))),a=o}if(0===l.length||0===y.length)return;u.fillParent(e,y,l),u.fillParent(e,l,y);const a=[];u.calcDeltas(a,y,l),u.calcDeltas(a,l,y),u.addDeltas(a,e)}static fillParent(t,i,e){const s=e.length,h=i.length;for(let r=0;r<h;r+=4){const h=i[r],x=i[r+1],y=i[r+2],o=t[h][x-1],a=t[h][x];let u=8092,c=-1;for(let i=0;i<s;i+=4){if(e[i+2]!==y)continue;const s=e[i],h=e[i+1],r=t[s][h-1],x=t[s][h];switch(y){case n.sideLeft:case n.sideRight:if((0,l.between)(o.y,r.y,x.y)&&(0,l.between)(a.y,r.y,x.y)){const t=Math.abs(x.y-r.y);t<u&&(u=t,c=i)}break;case n.sideTop:case n.sideBottom:if((0,l.between)(o.x,r.x,x.x)&&(0,l.between)(a.x,r.x,x.x)){const t=Math.abs(x.x-r.x);t<u&&(u=t,c=i)}}}i[r+3]=c}}static calcDeltas(t,i,e){const s=i.length;for(let n=0;n<s;n+=4){const s=[],h=u.calcDelta(n,i,e,s);t.push(i[n]),t.push(i[n+1]),t.push(i[n+2]),t.push(h)}}static calcDelta(t,i,e,s){const n=i[t+3];if(-1===n)return 0;const h=s.length;return h>1&&s[h-2]===n?0:(s.push(n),u.calcDelta(n,e,i,s)+1)}static addDeltas(t,i){const e=t.length;let s=0;for(let i=0;i<e;i+=4){const e=t[i+3];e>s&&(s=e)}for(let h=0;h<e;h+=4){const e=i[t[h]],r=t[h+1],x=s-t[h+3];switch(t[h+2]){case n.sideLeft:e[r-1].x-=x,e[r].x-=x,1===r&&(e[e.length-1].x-=x),r===e.length-1&&(e[0].x-=x);break;case n.sideRight:e[r-1].x+=x,e[r].x+=x,1===r&&(e[e.length-1].x+=x),r===e.length-1&&(e[0].x+=x);break;case n.sideTop:e[r-1].y-=x,e[r].y-=x,1===r&&(e[e.length-1].y-=x),r===e.length-1&&(e[0].y-=x);break;case n.sideBottom:e[r-1].y+=x,e[r].y+=x,1===r&&(e[e.length-1].y+=x),r===e.length-1&&(e[0].y+=x)}}}}})),i.register("brGzu",(function(e,s){t(e.exports,"LineTessellation",(function(){return p}));var n=i("k7j48"),h=i("aPQ4T");function r(t,i){return t.x===i.x&&t.y===i.y}function x(t,i){return t.x=i.y,t.y=-i.x,t}function l(t,i){return t.x=-i.y,t.y=i.x,t}function y(t,i){return t.x=i.x,t.y=i.y,t}function o(t,i){return t.x=-i.x,t.y=-i.y,t}function a(t){return Math.sqrt(t.x*t.x+t.y*t.y)}function u(t,i){return t.x*i.x+t.y*i.y}function c(t,i,e,s){return t.x=i.x*e+i.y*s,t.y=i.x*s-i.y*e,t}class p{tessellate(t,i){(function(t){if(!t)return;const i=t.length;if(i<=1)return;let e=0;for(let s=1;s<i;s++)r(t[s],t[e])||++e===s||(t[e]=t[s]);t.length=e+1})(t),this.canUseThinTessellation&&i.halfWidth<h.THIN_LINE_HALF_WIDTH_THRESHOLD&&!i.offset?this._tessellateThin(t,i):this._tessellate(t,i)}_tessellateThin(t,i){if(t.length<2)return;const e=i.wrapDistance||65535;let s=i.initialDistance||0,n=!1,h=t[0].x,r=t[0].y;const x=t.length;for(let i=1;i<x;++i){n&&(n=!1,s=0);let x=t[i].x,l=t[i].y,y=x-h,o=l-r,a=Math.sqrt(y*y+o*o);if(y/=a,o/=a,s+a>e){n=!0;const t=(e-s)/a;a=e-s,x=(1-t)*h+t*x,l=(1-t)*r+t*l,--i}const u=this.writeVertex(h,r,0,0,y,o,o,-y,0,-1,s),c=this.writeVertex(h,r,0,0,y,o,-o,y,0,1,s);s+=a;const p=this.writeVertex(x,l,0,0,y,o,o,-y,0,-1,s),m=this.writeVertex(x,l,0,0,y,o,-o,y,0,1,s);this.writeTriangle(u,c,p),this.writeTriangle(c,p,m),h=x,r=l}}_tessellate(t,i){const e=t[0],s=t[t.length-1],h=r(e,s),p=h?3:2;if(t.length<p)return;const m=i.pixelCoordRatio,f=null!=i.capType?i.capType:n.CapType.BUTT,d=null!=i.joinType?i.joinType:n.JoinType.MITER,g=null!=i.miterLimit?Math.min(i.miterLimit,4):2,T=null!=i.roundLimit?Math.min(i.roundLimit,1.05):1.05,_=null!=i.halfWidth?i.halfWidth:2,v=!!i.textured;let w,P,b=null,R=null;const E=this.prevNormal,M=this.nextNormal;let L=-1,N=-1;const V=this.joinNormal;let I,k;const D=this.textureNormalLeft,B=this.textureNormalRight,S=this.textureNormal;let U=-1,C=-1;const J=i.wrapDistance||65535;let H=i.initialDistance||0;const O=this.writeVertex,j=this.writeTriangle,A=(t,i,e,s,n,h)=>{const r=O(w,P,I,k,e,s,t,i,n,h,H);return U>=0&&C>=0&&r>=0&&j(U,C,r),U=C,C=r,r};h&&(b=t[t.length-2],M.x=s.x-b.x,M.y=s.y-b.y,N=a(M),M.x/=N,M.y/=N);let G=!1;for(let i=0;i<t.length;++i){if(G&&(G=!1,H=0),b&&(E.x=-M.x,E.y=-M.y,L=N,H+L>J&&(G=!0)),G){const e=(J-H)/L;L=J-H,b={x:(1-e)*b.x+e*t[i].x,y:(1-e)*b.y+e*t[i].y},--i}else b=t[i];w=b.x,P=b.y;const e=i<=0&&!G,s=i===t.length-1;if(e||(H+=L),R=s?h?t[1]:null:t[i+1],R?(M.x=R.x-w,M.y=R.y-P,N=a(M),M.x/=N,M.y/=N):(M.x=void 0,M.y=void 0),!h){if(e){l(V,M),I=V.x,k=V.y,f===n.CapType.SQUARE&&(A(-M.y-M.x,M.x-M.y,M.x,M.y,0,-1),A(M.y-M.x,-M.x-M.y,M.x,M.y,0,1)),f===n.CapType.ROUND&&(A(-M.y-M.x,M.x-M.y,M.x,M.y,-1,-1),A(M.y-M.x,-M.x-M.y,M.x,M.y,-1,1)),f!==n.CapType.ROUND&&f!==n.CapType.BUTT||(A(-M.y,M.x,M.x,M.y,0,-1),A(M.y,-M.x,M.x,M.y,0,1));continue}if(s){x(V,E),I=V.x,k=V.y,f!==n.CapType.ROUND&&f!==n.CapType.BUTT||(A(E.y,-E.x,-E.x,-E.y,0,-1),A(-E.y,E.x,-E.x,-E.y,0,1)),f===n.CapType.SQUARE&&(A(E.y-E.x,-E.x-E.y,-E.x,-E.y,0,-1),A(-E.y-E.x,E.x-E.y,-E.x,-E.y,0,1)),f===n.CapType.ROUND&&(A(E.y-E.x,-E.x-E.y,-E.x,-E.y,1,-1),A(-E.y-E.x,E.x-E.y,-E.x,-E.y,1,1));continue}}let r,p,O=(F=M,-((z=E).x*F.y-z.y*F.x));if(Math.abs(O)<.01)u(E,M)>0?(V.x=E.x,V.y=E.y,O=1,r=Number.MAX_VALUE,p=!0):(l(V,M),O=1,r=1,p=!1);else{V.x=(E.x+M.x)/O,V.y=(E.y+M.y)/O,r=a(V);const t=(r-1)*_*m;p=r>4||t>L&&t>N}I=V.x,k=V.y;let j=d;switch(d){case n.JoinType.BEVEL:r<1.05&&(j=n.JoinType.MITER);break;case n.JoinType.ROUND:r<T&&(j=n.JoinType.MITER);break;case n.JoinType.MITER:r>g&&(j=n.JoinType.BEVEL)}switch(j){case n.JoinType.MITER:if(A(V.x,V.y,-E.x,-E.y,0,-1),A(-V.x,-V.y,-E.x,-E.y,0,1),s)break;if(v){const t=G?0:H;U=this.writeVertex(w,P,I,k,M.x,M.y,V.x,V.y,0,-1,t),C=this.writeVertex(w,P,I,k,M.x,M.y,-V.x,-V.y,0,1,t)}break;case n.JoinType.BEVEL:{const t=O<0;let i,e,n,h;if(t){const t=U;U=C,C=t,i=D,e=B}else i=B,e=D;if(p)n=t?l(this.innerPrev,E):x(this.innerPrev,E),h=t?x(this.innerNext,M):l(this.innerNext,M);else{const i=t?o(this.inner,V):y(this.inner,V);n=i,h=i}const r=t?x(this.bevelStart,E):l(this.bevelStart,E);A(n.x,n.y,-E.x,-E.y,i.x,i.y);const a=A(r.x,r.y,-E.x,-E.y,e.x,e.y);if(s)break;const u=t?l(this.bevelEnd,M):x(this.bevelEnd,M);if(p){const t=this.writeVertex(w,P,I,k,-E.x,-E.y,0,0,0,0,H);U=this.writeVertex(w,P,I,k,M.x,M.y,h.x,h.y,i.x,i.y,H),C=this.writeVertex(w,P,I,k,M.x,M.y,u.x,u.y,e.x,e.y,H),this.writeTriangle(a,t,C)}else{if(v){const t=this.bevelMiddle;t.x=(r.x+u.x)/2,t.y=(r.y+u.y)/2,c(S,t,-E.x,-E.y),A(t.x,t.y,-E.x,-E.y,S.x,S.y),c(S,t,M.x,M.y),U=this.writeVertex(w,P,I,k,M.x,M.y,t.x,t.y,S.x,S.y,H),C=this.writeVertex(w,P,I,k,M.x,M.y,h.x,h.y,i.x,i.y,H)}else{const t=U;U=C,C=t}A(u.x,u.y,M.x,M.y,e.x,e.y)}if(t){const t=U;U=C,C=t}break}case n.JoinType.ROUND:{const t=O<0;let i,e;if(t){const t=U;U=C,C=t,i=D,e=B}else i=B,e=D;const n=t?o(this.inner,V):y(this.inner,V);let h,a;p?(h=t?l(this.innerPrev,E):x(this.innerPrev,E),a=t?x(this.innerNext,M):l(this.innerNext,M)):(h=n,a=n);const m=t?x(this.roundStart,E):l(this.roundStart,E),f=t?l(this.roundEnd,M):x(this.roundEnd,M),d=A(h.x,h.y,-E.x,-E.y,i.x,i.y),g=A(m.x,m.y,-E.x,-E.y,e.x,e.y);if(s)break;const T=this.writeVertex(w,P,I,k,-E.x,-E.y,0,0,0,0,H);p||this.writeTriangle(U,C,T);const _=o(this.outer,n),b=this.writeVertex(w,P,I,k,M.x,M.y,f.x,f.y,e.x,e.y,H);let R,L;const N=r>2;if(N){let i;r!==Number.MAX_VALUE?(_.x/=r,_.y/=r,i=u(E,_),i=(r*(i*i-1)+1)/i):i=-1,R=t?x(this.startBreak,E):l(this.startBreak,E),R.x+=E.x*i,R.y+=E.y*i,L=t?l(this.endBreak,M):x(this.endBreak,M),L.x+=M.x*i,L.y+=M.y*i}c(S,_,-E.x,-E.y);const J=this.writeVertex(w,P,I,k,-E.x,-E.y,_.x,_.y,S.x,S.y,H);c(S,_,M.x,M.y);const j=v?this.writeVertex(w,P,I,k,M.x,M.y,_.x,_.y,S.x,S.y,H):J,G=T,z=v?this.writeVertex(w,P,I,k,M.x,M.y,0,0,0,0,H):T;let F=-1,q=-1;if(N&&(c(S,R,-E.x,-E.y),F=this.writeVertex(w,P,I,k,-E.x,-E.y,R.x,R.y,S.x,S.y,H),c(S,L,M.x,M.y),q=this.writeVertex(w,P,I,k,M.x,M.y,L.x,L.y,S.x,S.y,H)),v?N?(this.writeTriangle(G,g,F),this.writeTriangle(G,F,J),this.writeTriangle(z,j,q),this.writeTriangle(z,q,b)):(this.writeTriangle(G,g,J),this.writeTriangle(z,j,b)):N?(this.writeTriangle(T,g,F),this.writeTriangle(T,F,q),this.writeTriangle(T,q,b)):(this.writeTriangle(T,g,J),this.writeTriangle(T,j,b)),p?(U=this.writeVertex(w,P,I,k,M.x,M.y,a.x,a.y,i.x,i.y,H),C=b):(U=v?this.writeVertex(w,P,I,k,M.x,M.y,a.x,a.y,i.x,i.y,H):d,this.writeTriangle(U,z,b),C=b),t){const t=U;U=C,C=t}break}}}var z,F}constructor(t,i,e){this.writeVertex=t,this.writeTriangle=i,this.canUseThinTessellation=e,this.prevNormal={x:void 0,y:void 0},this.nextNormal={x:void 0,y:void 0},this.textureNormalLeft={x:0,y:1},this.textureNormalRight={x:0,y:-1},this.textureNormal={x:void 0,y:void 0},this.joinNormal={x:void 0,y:void 0},this.inner={x:void 0,y:void 0},this.outer={x:void 0,y:void 0},this.roundStart={x:void 0,y:void 0},this.roundEnd={x:void 0,y:void 0},this.startBreak={x:void 0,y:void 0},this.endBreak={x:void 0,y:void 0},this.innerPrev={x:void 0,y:void 0},this.innerNext={x:void 0,y:void 0},this.bevelStart={x:void 0,y:void 0},this.bevelEnd={x:void 0,y:void 0},this.bevelMiddle={x:void 0,y:void 0}}}}));
//# sourceMappingURL=SymbolProcessor.35f902b8.js.map
