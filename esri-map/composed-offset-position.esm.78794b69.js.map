{"mappings":";;;;;GAMA,SAASA,EAAaC,GAClB,OAAOC,EAAqBD,E,CAQhC,SAASE,EAAeF,GACpB,OAAIA,EAAQG,aACDH,EAAQG,aAEfH,EAAQI,sBAAsBC,WACvBL,EAAQI,WAAWE,KAEvBN,EAAQI,U,CAanB,SAASH,EAAqBD,GAE1B,IAAK,IAAIO,EAAWP,EAASO,EAAUA,EAAWL,EAAeK,GAC7D,GAAMA,aAAoBC,SAGiB,SAAvCC,iBAAiBF,GAAUG,QAC3B,OAAO,KAGf,IAAK,IAAIC,EAAWT,EAAeF,GAAUW,EAAUA,EAAWT,EAAeS,GAAW,CACxF,KAAMA,aAAoBH,SACtB,SAEJ,MAAMI,EAAQH,iBAAiBE,GAE/B,GAAsB,aAAlBC,EAAMF,QAAV,CAGA,GAAuB,WAAnBE,EAAMC,UAA0C,SAAjBD,EAAME,OACrC,OAAOH,EAEX,GAAyB,SAArBA,EAASI,QACT,OAAOJ,CANP,C,CASR,OAAO,I","sources":["node_modules/@esri/calcite-components/dist/components/composed-offset-position.esm.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.4.3\n */\n/* eslint-disable @typescript-eslint/ban-types */\nfunction offsetParent(element) {\n    return offsetParentPolyfill(element);\n}\nfunction offsetTop(element) {\n    return offsetTopLeftPolyfill(element, 'offsetTop');\n}\nfunction offsetLeft(element) {\n    return offsetTopLeftPolyfill(element, 'offsetLeft');\n}\nfunction flatTreeParent(element) {\n    if (element.assignedSlot) {\n        return element.assignedSlot;\n    }\n    if (element.parentNode instanceof ShadowRoot) {\n        return element.parentNode.host;\n    }\n    return element.parentNode;\n}\nfunction ancestorTreeScopes(element) {\n    const scopes = new Set();\n    let currentScope = element.getRootNode();\n    while (currentScope) {\n        scopes.add(currentScope);\n        currentScope = currentScope.parentNode\n            ? currentScope.parentNode.getRootNode()\n            : null;\n    }\n    return scopes;\n}\nfunction offsetParentPolyfill(element) {\n    // Do an initial walk to check for display:none ancestors.\n    for (let ancestor = element; ancestor; ancestor = flatTreeParent(ancestor)) {\n        if (!(ancestor instanceof Element)) {\n            continue;\n        }\n        if (getComputedStyle(ancestor).display === 'none') {\n            return null;\n        }\n    }\n    for (let ancestor = flatTreeParent(element); ancestor; ancestor = flatTreeParent(ancestor)) {\n        if (!(ancestor instanceof Element)) {\n            continue;\n        }\n        const style = getComputedStyle(ancestor);\n        // Display:contents nodes aren't in the layout tree so they should be skipped.\n        if (style.display === 'contents') {\n            continue;\n        }\n        if (style.position !== 'static' || style.filter !== 'none') {\n            return ancestor;\n        }\n        if (ancestor.tagName === 'BODY') {\n            return ancestor;\n        }\n    }\n    return null;\n}\nfunction offsetTopLeftPolyfill(element, offsetTopOrLeft) {\n    let value = element[offsetTopOrLeft];\n    let nextOffsetParent = offsetParentPolyfill(element);\n    const scopes = ancestorTreeScopes(element);\n    while (nextOffsetParent && !scopes.has(nextOffsetParent.getRootNode())) {\n        value -= nextOffsetParent[offsetTopOrLeft];\n        nextOffsetParent = offsetParentPolyfill(nextOffsetParent);\n    }\n    return value;\n}\n\nexport { offsetLeft, offsetParent, offsetTop };\n"],"names":["$de725a1a34f1b7e1$export$759f2a42fd33dfde","element","$de725a1a34f1b7e1$var$offsetParentPolyfill","$de725a1a34f1b7e1$var$flatTreeParent","assignedSlot","parentNode","ShadowRoot","host","ancestor","Element","getComputedStyle","display","ancestor1","style","position","filter","tagName"],"version":3,"file":"composed-offset-position.esm.78794b69.js.map"}