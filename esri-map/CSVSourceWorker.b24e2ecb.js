function e(e,t,i,s){Object.defineProperty(e,t,{get:i,set:s,enumerable:!0,configurable:!0})}var t=("undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{}).parcelRequire594f;t.register("kcdKc",(function(i,s){e(i.exports,"default",(function(){return b}));var a=t("bPmsI"),r=t("itGIg"),n=t("1CpCt"),o=t("4B4sQ"),l=t("zPXCh"),u=t("ccOFp"),c=t("19dbe"),h=t("772GK"),d=t("86d4E"),f=t("hq5aB"),m=t("fau59"),p=t("7CVm9"),g=t("haPYR"),y=t("11H8e"),x=t("a9gdw"),_=t("hOW65"),S=t("UbUrW"),F=t("4JNri"),w=t("38xmB"),I=t("QiKdE"),E=t("cM1Gj");const R="feature-store:unsupported-query";const v=new Set,T=new(0,o.MemCacheStorage)(2e6);let Q=0;class b{destroy(){this._frameTask=(0,n.removeMaybe)(this._frameTask),this.clearCache(),(0,n.destroyMaybe)(this._geometryQueryCache),this._changeHandle=(0,n.removeMaybe)(this._changeHandle),(0,n.destroyMaybe)(this.fieldsIndex)}get featureAdapter(){return this.featureStore.featureAdapter}get fullExtent(){const e=this.featureStore.fullBounds;return e?{xmin:e[0],ymin:e[1],xmax:e[2],ymax:e[3],spatialReference:(0,F.cleanFromGeometryEngine)(this.spatialReference)}:null}get timeExtent(){return this.timeInfo?(this._timeExtent||(this._timeExtent=(0,S.getTimeExtent)(this.timeInfo,this.featureStore)),this._timeExtent):null}clearCache(){this._geometryQueryCache&&this._geometryQueryCache.clear(),this._allItems=null,this._timeExtent=null}async executeQuery(e={},t){let i,s=(0,r.clone)(e);try{s=await this._schedule((()=>(0,F.normalizeQuery)(s,this.definitionExpression,this.spatialReference)),t),s=await this._reschedule((()=>this._checkQuerySupport(s)),t),i=await this._reschedule((()=>this._executeGeometryQuery(s,t)),t),i=await this._reschedule((()=>i.executeAggregateIdsQuery(s)),t),i=await this._reschedule((()=>i.executeObjectIdsQuery(s)),t),i=await this._reschedule((()=>i.executeTimeQuery(s)),t),i=await this._reschedule((()=>i.executeAttributesQuery(s)),t)}catch(e){if(e!==F.QUERY_ENGINE_EMPTY_RESULT)throw e;i=new(0,x.default)([],null,this)}return i.createQueryResponse(s)}async executeQueryForCount(e={},t){let i=(0,r.clone)(e);i.returnGeometry=!1,i.returnCentroid=!1,i.outSR=null;try{i=await this._schedule((()=>(0,F.normalizeQuery)(i,this.definitionExpression,this.spatialReference)),t),i=await this._reschedule((()=>this._checkQuerySupport(i)),t);let e=await this._reschedule((()=>this._executeGeometryQuery(i,t)),t);return e=await this._reschedule((()=>e.executeAggregateIdsQuery(i)),t),e=await this._reschedule((()=>e.executeObjectIdsQuery(i)),t),e=await this._reschedule((()=>e.executeTimeQuery(i)),t),e=await this._reschedule((()=>e.executeAttributesQuery(i)),t),e.createQueryResponseForCount(i)}catch(e){if(e!==F.QUERY_ENGINE_EMPTY_RESULT)throw e;return 0}}async executeQueryForExtent(e={},t){let i,s=(0,r.clone)(e);const a=s.outSR;try{s=await this._schedule((()=>(0,F.normalizeQuery)(s,this.definitionExpression,this.spatialReference)),t),s=await this._reschedule((()=>this._checkQuerySupport(s)),t),s.returnGeometry=!0,s.returnCentroid=!1,s.outSR=null,i=await this._reschedule((()=>this._executeGeometryQuery(s,t)),t),i=await this._reschedule((()=>i.executeAggregateIdsQuery(s)),t),i=await this._reschedule((()=>i.executeObjectIdsQuery(s)),t),i=await this._reschedule((()=>i.executeTimeQuery(s)),t),i=await this._reschedule((()=>i.executeAttributesQuery(s)),t);const e=i.size;if(!e)return{count:e,extent:null};(0,u.set)(C,u.NEGATIVE_INFINITY),this.featureStore.forEachBounds(i.items,(e=>(0,u.expandWithAABB)(C,e)),A);const r={xmin:C[0],ymin:C[1],xmax:C[3],ymax:C[4],spatialReference:(0,F.cleanFromGeometryEngine)(this.spatialReference)};this.hasZ&&isFinite(C[2])&&isFinite(C[5])&&(r.zmin=C[2],r.zmax=C[5]);const n=(0,g.project)(r,i.spatialReference,a);if(n.spatialReference=(0,F.cleanFromGeometryEngine)(a||this.spatialReference),n.xmax-n.xmin==0){const e=(0,l.getMetersPerUnitForSR)(n.spatialReference);n.xmin-=e,n.xmax+=e}if(n.ymax-n.ymin==0){const e=(0,l.getMetersPerUnitForSR)(n.spatialReference);n.ymin-=e,n.ymax+=e}if(this.hasZ&&null!=n.zmin&&null!=n.zmax&&n.zmax-n.zmin==0){const e=(0,l.getMetersPerUnitForSR)(n.spatialReference);n.zmin-=e,n.zmax+=e}return{count:e,extent:n}}catch(e){if(e===F.QUERY_ENGINE_EMPTY_RESULT)return{count:0,extent:null};throw e}}async executeQueryForIds(e={},t){return this.executeQueryForIdSet(e,t).then((e=>Array.from(e)))}async executeQueryForIdSet(e={},t){let i,s=(0,r.clone)(e);s.returnGeometry=!1,s.returnCentroid=!1,s.outSR=null;try{s=await this._schedule((()=>(0,F.normalizeQuery)(s,this.definitionExpression,this.spatialReference)),t),s=await this._reschedule((()=>this._checkQuerySupport(s)),t),i=await this._reschedule((()=>this._executeGeometryQuery(s,t)),t),i=await this._reschedule((()=>i.executeAggregateIdsQuery(s)),t),i=await this._reschedule((()=>i.executeObjectIdsQuery(s)),t),i=await this._reschedule((()=>i.executeTimeQuery(s)),t),i=await this._reschedule((()=>i.executeAttributesQuery(s)),t);const e=i.items,a=new Set;return await this._reschedule((()=>{for(const t of e)a.add(i.featureAdapter.getObjectId(t))}),t),a}catch(e){if(e===F.QUERY_ENGINE_EMPTY_RESULT)return new Set;throw e}}async executeQueryForSnapping(e,t){const{point:i,distance:s,types:a}=e;if(a===x.SnappingTypes.NONE)return{candidates:[]};const r=await this._reschedule((()=>this._checkQuerySupport(e.query)),t),o=!(0,m.equals)(i.spatialReference,this.spatialReference);o&&await(0,g.checkProjectionSupport)(i.spatialReference,this.spatialReference);const l="number"==typeof s?s:s.x,u="number"==typeof s?s:s.y,c={xmin:i.x-l,xmax:i.x+l,ymin:i.y-u,ymax:i.y+u,spatialReference:i.spatialReference},h=o?(0,g.project)(c,this.spatialReference):c;if(!h)return{candidates:[]};const p=(await(0,f.normalizeCentralMeridian)((0,d.fromJSON)(i),null,{signal:t}))[0],y=(await(0,f.normalizeCentralMeridian)((0,d.fromJSON)(h),null,{signal:t}))[0];if((0,n.isNone)(p)||(0,n.isNone)(y))return{candidates:[]};let _=new(0,x.default)(this._searchFeatures(this._getQueryBBoxes(y.toJSON())),null,this);_=await this._reschedule((()=>_.executeObjectIdsQuery(r)),t),_=await this._reschedule((()=>_.executeTimeQuery(r)),t),_=await this._reschedule((()=>_.executeAttributesQuery(r)),t);const S=p.toJSON(),F=o?(0,g.project)(S,this.spatialReference):S,w=o?Math.max(h.xmax-h.xmin,h.ymax-h.ymin)/2:s;return _.createSnappingResponse({...e,point:F,distance:w},i.spatialReference)}async executeQueryForLatestObservations(e={},t){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new(0,a.default)(R,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});let i,s=(0,r.clone)(e);try{s=await this._schedule((()=>(0,F.normalizeQuery)(s,this.definitionExpression,this.spatialReference)),t),s=await this._reschedule((()=>this._checkQuerySupport(s)),t),i=await this._reschedule((()=>this._executeGeometryQuery(s,t)),t),i=await this._reschedule((()=>i.executeAggregateIdsQuery(s)),t),i=await this._reschedule((()=>i.executeObjectIdsQuery(s)),t),i=await this._reschedule((()=>i.executeTimeQuery(s)),t),i=await this._reschedule((()=>i.executeAttributesQuery(s)),t),i=await this._reschedule((()=>i.filterLatest()),t)}catch(e){if(e!==F.QUERY_ENGINE_EMPTY_RESULT)throw e;i=new(0,x.default)([],null,this)}return i.createQueryResponse(s)}async executeQueryForSummaryStatistics(e={},t,i){const{field:s,normalizationField:a,valueExpression:r}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:a,valueExpression:r},i)).createSummaryStatisticsResponse(e,t)}async executeQueryForUniqueValues(e={},t,i){const{field:s,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:s,valueExpression:a},i)).createUniqueValuesResponse(e,t)}async executeQueryForClassBreaks(e={},t,i){const{field:s,normalizationField:a,valueExpression:r}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:a,valueExpression:r},i)).createClassBreaksResponse(e,t)}async executeQueryForHistogram(e={},t,i){const{field:s,normalizationField:a,valueExpression:r}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:a,valueExpression:r},i)).createHistogramResponse(e,t)}async _schedule(e,t){return(0,n.isSome)(this._frameTask)?this._frameTask.schedule(e,t):e(E.noBudget)}async _reschedule(e,t){return(0,n.isSome)(this._frameTask)?this._frameTask.reschedule(e,t):e(E.noBudget)}_getAll(){if(!this._allItems){const e=[];this.featureStore.forEach((t=>e.push(t))),this._allItems=new(0,x.default)(e,null,this)}return this._allItems}async _executeGeometryQuery(e,t){const{geometry:i,outSR:s,spatialRel:a,returnGeometry:r,returnCentroid:o}=e,l=this.featureStore.featureSpatialReference,u=i&&l&&l!==i.spatialReference?(0,g.project)(i,l):i,c=r||o,h=(0,m.isValid)(s)&&!(0,m.equals)(this.spatialReference,s),d=this._geometryQueryCache?h&&c?JSON.stringify({originalFilterGeometry:i,spatialRelationship:a,outSpatialReference:s}):JSON.stringify({originalFilterGeometry:i,spatialRelationship:a}):null;if(d){const e=this._geometryQueryCache.get(d);if(!(0,n.isUndefined)(e))return e}const f=async e=>{if(h&&c){const t=await e.project(s);return d&&this._geometryQueryCache.put(d,t,t.size||1),t}return d&&this._geometryQueryCache.put(d,e,e.size||1),e};if(!u)return f(this._getAll());const p=this.featureAdapter;if("esriSpatialRelDisjoint"===a){const e=this._searchFeatures(this._getQueryBBoxes(i));if(!e.length)return f(this._getAll());let s,r;const n=new Set;for(const t of e)n.add(p.getObjectId(t));await this._reschedule((()=>{let e=0;s=new Array(n.size),this.featureStore.forEach((t=>s[e++]=t)),r=n}),t);return f(await this._reschedule((async()=>{const e=await(0,_.getSpatialQueryOperator)(a,u,this.geometryType,this.hasZ,this.hasM);return new(0,x.default)(await this._runSpatialFilter(s,(t=>!r.has(p.getObjectId(t))||e(p.getGeometry(t))),t),i,this)}),t))}const y=this._searchFeatures(this._getQueryBBoxes(i));if(!y.length){const e=new(0,x.default)([],i,this);return d&&this._geometryQueryCache.put(d,e,e.size||1),e}if(this._canExecuteSoloPass(u,e))return f(new(0,x.default)(y,i,this));const S=await(0,_.getSpatialQueryOperator)(a,u,this.geometryType,this.hasZ,this.hasM),F=await this._runSpatialFilter(y,(e=>S(p.getGeometry(e))),t);return f(new(0,x.default)(F,i,this))}async _runSpatialFilter(e,t,i){if(!t)return e;if((0,n.isNone)(this._frameTask))return e.filter((e=>t(e)));let s=0;const a=new Array,r=async n=>{for(;s<e.length;){const o=e[s++];t(o)&&(a.push(o),n.madeProgress()),n.done&&await this._reschedule((e=>r(e)),i)}};return this._reschedule((e=>r(e)),i).then((()=>a))}_canExecuteSoloPass(e,t){const{geometryType:i}=this,{spatialRel:s}=t;return(0,_.canQueryWithRBush)(e)&&("esriSpatialRelEnvelopeIntersects"===s||"esriGeometryPoint"===i&&("esriSpatialRelIntersects"===s||"esriSpatialRelContains"===s||"esriSpatialRelWithin"===s))}_getQueryBBoxes(e){if((0,_.canQueryWithRBush)(e)){if((0,d.isExtent)(e))return[(0,c.fromValues)(e.xmin,e.ymin,e.xmax,e.ymax)];if((0,d.isPolygon)(e))return e.rings.map((e=>(0,c.fromValues)(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1]))))}return[(0,h.getBoundsXY)((0,c.create)(),e)]}_searchFeatures(e){for(const t of e)this.featureStore.forEachInBounds(t,(e=>{v.add(e)}));const t=new Array(v.size);let i=0;return v.forEach((e=>t[i++]=e)),v.clear(),t}async _checkStatisticsSupport(e,t){if(e.distance<0||null!=e.geometryPrecision||e.multipatchOption||e.pixelSize||e.relationParam||e.text||e.outStatistics||e.groupByFieldsForStatistics||e.having||e.orderByFields)throw new(0,a.default)(R,"Unsupported query options",{query:e});return Promise.all([this._checkAttributesQuerySupport(e),this._checkStatisticsParamsSupport(t),(0,_.checkSpatialQuerySupport)(e,this.geometryType,this.spatialReference),(0,g.checkProjectionSupport)(this.spatialReference,e.outSR)]).then((()=>e))}async _checkStatisticsParamsSupport(e){let t=[];if(e.valueExpression){const{arcadeUtils:i}=await(0,I.loadArcade)();t=i.extractFieldNames(e.valueExpression)}if(e.field&&t.push(e.field),e.normalizationField&&t.push(e.normalizationField),!t.length)throw new(0,a.default)(R,"params should have at least a field or valueExpression",{params:e});(0,p.validateFields)(this.fieldsIndex,t,"params contains missing fields")}async _checkQuerySupport(e){if(e.distance<0||null!=e.geometryPrecision||e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new(0,a.default)(R,"Unsupported query options",{query:e});return Promise.all([this._checkAttributesQuerySupport(e),this._checkStatisticsQuerySupport(e),(0,_.checkSpatialQuerySupport)(e,this.geometryType,this.spatialReference),(0,g.checkProjectionSupport)(this.spatialReference,e.outSR)]).then((()=>e))}_checkAttributesQuerySupport(e){const{outFields:t,orderByFields:i,returnDistinctValues:s,outStatistics:r}=e,n=r?r.map((e=>e.outStatisticFieldName&&e.outStatisticFieldName.toLowerCase())).filter(Boolean):[];if(i&&i.length>0){const e=" asc",t=" desc",s=i.map((i=>{const s=i.toLowerCase();return s.indexOf(e)>-1?s.split(e)[0]:s.indexOf(t)>-1?s.split(t)[0]:i})).filter((e=>-1===n.indexOf(e)));(0,p.validateFields)(this.fieldsIndex,s,"orderByFields contains missing fields")}if(t&&t.length>0)(0,p.validateFields)(this.fieldsIndex,t,"outFields contains missing fields");else if(s)throw new(0,a.default)(R,"outFields should be specified for returnDistinctValues",{query:e});(0,p.validateWhere)(this.fieldsIndex,e.where)}async _checkStatisticsQuerySupport(e){const{outStatistics:t,groupByFieldsForStatistics:i,having:s}=e,r=i&&i.length,n=t&&t.length;if(s){if(!r||!n)throw new(0,a.default)(R,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:e});(0,p.validateHaving)(this.fieldsIndex,s,t)}if(n){if(!t.every((e=>"exceedslimit"!==e.statisticType)))return;const s=t.map((e=>e.onStatisticField)).filter(Boolean);(0,p.validateFields)(this.fieldsIndex,s,"onStatisticFields contains missing fields"),r&&(0,p.validateFields)(this.fieldsIndex,i,"groupByFieldsForStatistics contains missing fields");for(const i of t){const{onStatisticField:t,statisticType:s}=i;if("percentile_disc"!==s&&"percentile_cont"!==s||!("statisticParameters"in i)){if("count"!==s&&t&&(0,p.hasInvalidFieldType)(t,this.fieldsIndex))throw new(0,a.default)(R,"outStatistics contains non-numeric fields",{definition:i,query:e})}else{const{statisticParameters:t}=i;if(!t)throw new(0,a.default)(R,"statisticParamters should be set for percentile type",{definition:i,query:e})}}}}async _getQueryEngineResultForStats(e={},t,i){let s;e=(0,r.clone)(e);try{e=await this._schedule((()=>(0,F.normalizeQuery)(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>this._checkStatisticsSupport(e,t)),i),s=await this._reschedule((()=>this._executeGeometryQuery(e,i)),i),s=await this._reschedule((()=>s.executeAggregateIdsQuery(e)),i),s=await this._reschedule((()=>s.executeObjectIdsQuery(e)),i),s=await this._reschedule((()=>s.executeTimeQuery(e)),i),s=await this._reschedule((()=>s.executeAttributesQuery(e)),i)}catch(e){if(e!==F.QUERY_ENGINE_EMPTY_RESULT)throw e;s=new(0,x.default)([],null,this)}return s}constructor(e){this.capabilities={query:y.queryCapabilities},this.geometryType=e.geometryType,this.hasM=e.hasM,this.hasZ=e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",(()=>this.clearCache())),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new(0,o.MemCache)(Q+++"$$",T)),this.fieldsIndex=new(0,w.default)(e.fields),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}}const A=(0,u.create)(),C=(0,u.create)()})),t.register("7CVm9",(function(i,s){e(i.exports,"validateWhere",(function(){return u})),e(i.exports,"validateFields",(function(){return d})),e(i.exports,"validateHaving",(function(){return c})),e(i.exports,"getWhereClause",(function(){return h})),e(i.exports,"getExpressionFromFieldName",(function(){return f})),e(i.exports,"getAliasFromFieldName",(function(){return m})),e(i.exports,"hasInvalidFieldType",(function(){return p}));var a=t("bPmsI");const r=new(0,t("12q3i").WhereClauseCache)(50,500),n="feature-store:unsupported-query",o=" as ",l=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function u(e,t){if(!t)return!0;const i=r.get(t,e);if(!i)throw new(0,a.default)(n,"invalid SQL expression",{where:t});if(!i.isStandardized)throw new(0,a.default)(n,"where clause is not standard",{where:t});return d(e,i.fieldNames,"where clause contains missing fields"),!0}function c(e,t,i){if(!t)return!0;const s=r.get(t,e);if(!s)throw new(0,a.default)(n,"invalid SQL expression",{having:t});if(!s.isAggregate)throw new(0,a.default)(n,"having does not contain a valid aggregate function",{having:t});const o=s.fieldNames;if(d(e,o,"having contains missing fields"),!s.getExpressions().every((t=>{const{aggregateType:s,field:a}=t,r=e.has(a)&&e.get(a).name;return i.some((t=>{const{onStatisticField:i,statisticType:a}=t;return(e.has(i)&&e.get(i).name)===r&&a.toLowerCase().trim()===s}))})))throw new(0,a.default)(n,"expressions in having should also exist in outStatistics",{having:t});return!0}function h(e,t){return e?r.get(e,t):null}function d(e,t,i,s=!0){const r=[];for(const i of t)if("*"!==i&&!e.has(i))if(s){const t=f(i);try{const i=h(t,e);if(!i)throw new(0,a.default)(n,"invalid SQL expression",{where:t});if(!i.isStandardized)throw new(0,a.default)(n,"expression is not standard",{clause:i});d(e,i.fieldNames,"expression contains missing fields")}catch(e){const t=e&&e.details;if(t&&(t.clause||t.where))throw e;t&&t.missingFields?r.push(...t.missingFields):r.push(i)}}else r.push(i);if(r.length)throw new(0,a.default)(n,i,{missingFields:r})}function f(e){return e.split(o)[0]}function m(e){return e.split(o)[1]}function p(e,t){const i=t.get(e);return!!i&&!l.has(i.type)}})),t.register("12q3i",(function(i,s){e(i.exports,"WhereClauseCache",(function(){return n}));var a=t("iyNmW"),r=t("jKVXg");class n{get(e,t){const i=`${t.uid}:${e}`,s=this._cache.get(i);if(s)return s;if(void 0!==this._invalidCache.get(i))return null;try{const s=r.WhereClause.create(e,t);return this._cache.put(i,s),s}catch{return this._invalidCache.put(i,null),null}}constructor(e,t){this._cache=new(0,a.default)(e),this._invalidCache=new(0,a.default)(t)}}})),t.register("a9gdw",(function(i,s){e(i.exports,"default",(function(){return S})),e(i.exports,"SnappingTypes",(function(){return a}));var a,r,n=t("1CpCt"),o=t("2oFSF"),l=t("lHXAI"),u=t("1kNSi"),c=t("fau59"),h=t("8RZNq"),d=t("cWVjE"),f=t("7CVm9"),m=t("haPYR"),p=t("UbUrW"),g=t("4JNri"),y=t("15IfA"),x=t("i3NJS"),_=t("QiKdE");class S{get size(){return this.items.length}createQueryResponseForCount(e){const t=new(0,d.default)(e,this.featureAdapter,this.fieldsIndex);if(!e.outStatistics)return t.countDistinctValues(this.items);const{groupByFieldsForStatistics:i,having:s}=e;if(!(null==i?void 0:i.length))return 1;const a=new Map,r=new Map,n=new Set,o=e.outStatistics;for(const e of o){const{statisticType:o}=e,l="exceedslimit"!==o?e.onStatisticField:void 0;if(!r.has(l)){const e=[];for(const s of i){const i=this._getAttributeValues(t,s,a);e.push(i)}r.set(l,this._calculateUniqueValues(e,t.returnDistinctValues))}const u=r.get(l);for(const e in u){const{data:i,items:a}=u[e],r=i.join(",");s&&!t.validateItems(a,s)||n.add(r)}}return n.size}async createQueryResponse(e){let t;return t=e.outStatistics?e.outStatistics.some((e=>"exceedslimit"===e.statisticType))?this._createExceedsLimitQueryResponse(e):await this._createStatisticsQueryResponse(e):this._createFeatureQueryResponse(e),e.returnQueryGeometry&&((0,c.isValid)(e.outSR)&&!(0,c.equals)(this.queryGeometry.spatialReference,e.outSR)?t.queryGeometry=(0,g.cleanFromGeometryEngine)({spatialReference:e.outSR,...(0,m.project)(this.queryGeometry,this.queryGeometry.spatialReference,e.outSR)}):t.queryGeometry=(0,g.cleanFromGeometryEngine)({spatialReference:e.outSR,...this.queryGeometry})),t}createSnappingResponse(e,t){const i=this.featureAdapter,s=(f=this.hasZ,m=this.hasM,f?m?4:3:m?3:2),{x:r,y:o}=e.point,l="number"==typeof e.distance?e.distance:e.distance.x,u="number"==typeof e.distance?e.distance:e.distance.y,c={candidates:[]},h="esriGeometryPolygon"===this.geometryType,d=this._getPointCreator(e.point,this.spatialReference,t);var f,m;for(const t of this.items){const f=i.getGeometry(t);if((0,n.isNone)(f))continue;const{coords:m,lengths:p}=f;if(e.types&a.EDGE){let e=0;for(let a=0;a<p.length;a++){const n=p[a];for(let a=0;a<n;a++,e+=s){const h=m[e],f=m[e+1];if(a!==n-1){const a=m[e+s],n=m[e+s+1],{x:p,y:g}=F(r,o,h,f,a,n),y=(r-p)/l,x=(o-g)/u,_=y*y+x*x;_<=1&&c.candidates.push({type:"edge",objectId:i.getObjectId(t),distance:Math.sqrt(_),target:d(p,g),start:d(h,f),end:d(a,n)})}}}}if(e.types&a.VERTEX){const e=h?m.length-s:m.length;for(let a=0;a<e;a+=s){const e=m[a],s=m[a+1],n=(r-e)/l,h=(o-s)/u,f=n*n+h*h;f<=1&&c.candidates.push({type:"vertex",objectId:i.getObjectId(t),distance:Math.sqrt(f),target:d(e,s)})}}}return c.candidates.sort(((e,t)=>e.distance-t.distance)),c}_getPointCreator(e,t,i){const s=(0,n.isSome)(i)&&!(0,c.equals)(t,i)?e=>(0,m.project)(e,t,i):e=>e;return null!=e.z&&null!=e.m?(t,i)=>s({x:t,y:i,z:e.z,m:e.m}):null!=e.z?(t,i)=>s({x:t,y:i,z:e.z}):null!=e.m?(t,i)=>s({x:t,y:i,m:e.m}):(e,t)=>s({x:e,y:t})}executeAttributesQuery(e){const t=(0,f.getWhereClause)(e.where,this.fieldsIndex);if(!t)return Promise.resolve(this);if(t.isStandardized){let i=0;const s=[];for(const e of this.items)t.testFeature(e,this.featureAdapter)&&(s[i++]=e);const a=new S(s,this.queryGeometry,this);return a.definitionExpression=e.where,Promise.resolve(a)}return Promise.reject(new TypeError("Where clause is not standardized"))}executeAggregateIdsQuery(e){if(!e.aggregateIds||!e.aggregateIds.length||(0,n.isNone)(this.aggregateAdapter))return Promise.resolve(this);const t=new Set;for(const i of e.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(i).forEach((e=>t.add(e)));const i=this.featureAdapter.getObjectId;return Promise.resolve(new S(this.items.filter((e=>t.has(i(e)))),this.queryGeometry,this))}executeObjectIdsQuery(e){if(!e.objectIds||!e.objectIds.length)return Promise.resolve(this);const t=new Set(e.objectIds),i=this.featureAdapter.getObjectId;return Promise.resolve(new S(this.items.filter((e=>t.has(i(e)))),this.queryGeometry,this))}executeTimeQuery(e){const t=(0,p.getTimeOperator)(this.timeInfo,e.timeExtent,this.featureAdapter);if(!(0,n.isSome)(t))return Promise.resolve(this);const i=this.items.filter(t);return Promise.resolve(new S(i,this.queryGeometry,this))}filterLatest(){const{trackIdField:e,startTimeField:t,endTimeField:i}=this.timeInfo,s=i||t,a=new Map,r=this.featureAdapter.getAttribute;for(const t of this.items){const i=r(t,e),n=r(t,s),o=a.get(i);(!o||n>r(o,s))&&a.set(i,t)}const n=Array.from(a.values());return Promise.resolve(new S(n,this.queryGeometry,this))}async project(e){if(!e||(0,c.equals)(this.spatialReference,e))return this;const t=this.featureAdapter,i=(await(0,m.projectMany)(this.items.map((e=>(0,g.getGeometry)(this.geometryType,this.hasZ,this.hasM,t.getGeometry(e)))),this.spatialReference,e)).map(((e,i)=>t.cloneWithGeometry(this.items[i],(0,h.convertFromGeometry)(e,this.hasZ,this.hasM))));return new S(i,this.queryGeometry,{definitionExpression:this.definitionExpression,geometryType:this.geometryType,hasM:this.hasM,hasZ:this.hasZ,objectIdField:this.objectIdField,spatialReference:e,fieldsIndex:this.fieldsIndex,timeInfo:this.timeInfo,featureAdapter:this.featureAdapter})}async createSummaryStatisticsResponse(e,t){const{field:i,valueExpression:s,normalizationField:a,normalizationType:r,normalizationTotal:n,minValue:o,maxValue:l,scale:u}=t,c=this.fieldsIndex.isDateField(i),h=await this._getDataValues(e,{field:i,valueExpression:s,normalizationField:a,normalizationType:r,normalizationTotal:n,scale:u}),d=(0,x.isNullCountSupported)({normalizationType:r,normalizationField:a,minValue:o,maxValue:l}),f=this.fieldsIndex.get(i),m={value:.5,fieldType:null==f?void 0:f.type},p=(0,y.isStringField)(f)?(0,x.calculateStringStatistics)({values:h,supportsNullCount:d,percentileParams:m}):(0,x.calculateStatistics)({values:h,minValue:o,maxValue:l,useSampleStdDev:!r,supportsNullCount:d,percentileParams:m});return(0,x.processSummaryStatisticsResult)(p,c)}async createUniqueValuesResponse(e,t){const{field:i,valueExpression:s,domain:a,returnAllCodedValues:r,scale:n}=t,o=await this._getDataValues(e,{field:i,valueExpression:s,scale:n}),l=(0,x.calculateUniqueValuesCount)(o);return(0,x.createUVResult)(l,a,r)}async createClassBreaksResponse(e,t){const{field:i,valueExpression:s,normalizationField:a,normalizationType:r,normalizationTotal:n,classificationMethod:o,standardDeviationInterval:l,minValue:u,maxValue:c,numClasses:h,scale:d}=t,f=await this._getDataValues(e,{field:i,valueExpression:s,normalizationField:a,normalizationType:r,normalizationTotal:n,scale:d}),m=(0,x.calculateClassBreaks)(f,{field:i,normalizationField:a,normalizationType:r,normalizationTotal:n,classificationMethod:o,standardDeviationInterval:l,minValue:u,maxValue:c,numClasses:h});return(0,x.resolveCBResult)(m,o)}async createHistogramResponse(e,t){const{field:i,valueExpression:s,normalizationField:a,normalizationType:r,normalizationTotal:n,classificationMethod:o,standardDeviationInterval:l,minValue:u,maxValue:c,numBins:h,scale:d}=t,f=await this._getDataValues(e,{field:i,valueExpression:s,normalizationField:a,normalizationType:r,normalizationTotal:n,scale:d});return(0,x.calculateHistogram)(f,{field:i,normalizationField:a,normalizationType:r,normalizationTotal:n,classificationMethod:o,standardDeviationInterval:l,minValue:u,maxValue:c,numBins:h})}_sortFeatures(e,t,i){if(e.length>1&&t&&t.length)for(const s of t.reverse()){const t=s.split(" "),a=t[0],r=this.fieldsIndex.get(a),n=t[1]&&"desc"===t[1].toLowerCase(),o=(0,x.getAttributeComparator)(null==r?void 0:r.type,n);e.sort(((e,t)=>{const s=i(e,a,r),n=i(t,a,r);return o(s,n)}))}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:i,hasM:s,hasZ:a,objectIdField:r,spatialReference:n}=this,{outFields:o,outSR:l,quantizationParameters:c,resultRecordCount:h,resultOffset:d,returnZ:f,returnM:m}=e,p=null!=h&&t.length>(d||0)+h,y=o&&(o.includes("*")?[...this.fieldsIndex.fields]:o.map((e=>this.fieldsIndex.get(e))));return{exceededTransferLimit:p,features:this._createFeatures(e,t),fields:y,geometryType:i,hasM:s&&m,hasZ:a&&f,objectIdFieldName:r,spatialReference:(0,g.cleanFromGeometryEngine)(l||n),transform:c&&(0,u.toQuantizationTransform)(c)||null}}_createFeatures(e,t){const i=new(0,d.default)(e,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:a}=this,{orderByFields:r,quantizationParameters:n,returnGeometry:o,returnCentroid:l,maxAllowableOffset:c,resultOffset:h,resultRecordCount:f,returnZ:m=!1,returnM:p=!1}=e,y=a&&m,x=s&&p;let _=[],S=0;const F=[...t];if(this._sortFeatures(F,r,((e,t,s)=>i.getFieldValue(e,t,s))),o||l){const e=(0,u.toQuantizationTransform)(n);if(o&&!l)for(const t of F)_[S++]={attributes:i.getAttributes(t),geometry:(0,g.getGeometry)(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),c,e,y,x)};else if(!o&&l)for(const t of F)_[S++]={attributes:i.getAttributes(t),centroid:(0,g.transformCentroid)(this,this.featureAdapter.getCentroid(t,this),e)};else for(const t of F)_[S++]={attributes:i.getAttributes(t),centroid:(0,g.transformCentroid)(this,this.featureAdapter.getCentroid(t,this),e),geometry:(0,g.getGeometry)(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),c,e,y,x)}}else for(const e of F){const t=i.getAttributes(e);t&&(_[S++]={attributes:t})}const w=h||0;if(null!=f){const e=w+f;_=_.slice(w,Math.min(_.length,e))}return _}_createExceedsLimitQueryResponse(e){let t=!1,i=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY;for(const t of e.outStatistics)if("exceedslimit"===t.statisticType){i=null!=t.maxPointCount?t.maxPointCount:Number.POSITIVE_INFINITY,s=null!=t.maxRecordCount?t.maxRecordCount:Number.POSITIVE_INFINITY,a=null!=t.maxVertexCount?t.maxVertexCount:Number.POSITIVE_INFINITY;break}if("esriGeometryPoint"===this.geometryType)t=this.items.length>i;else if(this.items.length>s)t=!0;else{const e=this.hasZ?this.hasM?4:3:this.hasM?3:2,i=this.featureAdapter;t=this.items.reduce(((e,t)=>{const s=i.getGeometry(t);return e+((0,n.isSome)(s)&&s.coords.length||0)}),0)/e>a}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(t)}}]}}async _createStatisticsQueryResponse(e){const t={attributes:{}},i=[],s=new Map,a=new Map,r=new Map,n=new Map,o=new(0,d.default)(e,this.featureAdapter,this.fieldsIndex),l=e.outStatistics,{groupByFieldsForStatistics:u,having:c,orderByFields:h}=e,f=u&&u.length,m=!!f,p=m&&u[0],g=m&&!this.fieldsIndex.get(p);for(const e of l){const{outStatisticFieldName:l,statisticType:h}=e,d=e,y="exceedslimit"!==h?e.onStatisticField:void 0,x="percentile_disc"===h||"percentile_cont"===h,_="EnvelopeAggregate"===h||"CentroidAggregate"===h||"ConvexHullAggregate"===h,S=m&&1===f&&(y===p||g)&&"count"===h;if(m){if(!r.has(y)){const e=[];for(const t of u){const i=this._getAttributeValues(o,t,s);e.push(i)}r.set(y,this._calculateUniqueValues(e,o.returnDistinctValues))}const e=r.get(y);for(const t in e){const{count:i,data:a,items:r,itemPositions:h}=e[t],f=a.join(",");if(!c||o.validateItems(r,c)){const e=n.get(f)||{attributes:{}};if(_){e.aggregateGeometries||(e.aggregateGeometries={});const{aggregateGeometries:t,outStatisticFieldName:i}=await this._getAggregateGeometry(d,r);e.aggregateGeometries[i]=t}else{let t=null;if(S)t=i;else{const e=this._getAttributeValues(o,y,s),i=h.map((t=>e[t]));t=x&&"statisticParameters"in d?this._getPercentileValue(d,i):this._getStatisticValue(d,i,null,o.returnDistinctValues)}e.attributes[l]=t}u.forEach(((t,i)=>e.attributes[this.fieldsIndex.get(t)?t:`EXPR_${i+1}`]=a[i])),n.set(f,e)}}}else if(_){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:i}=await this._getAggregateGeometry(d,this.items);t.aggregateGeometries[i]=e}else{const e=this._getAttributeValues(o,y,s);t.attributes[l]=x&&"statisticParameters"in d?this._getPercentileValue(d,e):this._getStatisticValue(d,e,a,o.returnDistinctValues)}i.push({name:l,alias:l,type:"esriFieldTypeDouble"})}const y=m?Array.from(n.values()):[t];return this._sortFeatures(y,h,((e,t)=>e.attributes[t])),{fields:i,features:y}}async _getAggregateGeometry(e,i){const s=await t("jatML"),{statisticType:a,outStatisticFieldName:r}=e,{featureAdapter:n,spatialReference:u,geometryType:c,hasZ:h,hasM:d}=this,f=i.map((e=>(0,g.getGeometry)(c,h,d,n.getGeometry(e)))),m=s.convexHull(u,f,!0)[0],p={aggregateGeometries:null,outStatisticFieldName:null};if("EnvelopeAggregate"===a){const e=m?(0,l.getPolygonExtent)(m):(0,l.getGeometryExtent)(s.union(u,f));p.aggregateGeometries={...e,spatialReference:u},p.outStatisticFieldName=r||"extent"}else if("CentroidAggregate"===a){const e=m?(0,o.polygonCentroid)(m):(0,o.extentCentroid)((0,l.getGeometryExtent)(s.union(u,f)));p.aggregateGeometries={x:e[0],y:e[1],spatialReference:u},p.outStatisticFieldName=r||"centroid"}else"ConvexHullAggregate"===a&&(p.aggregateGeometries=m,p.outStatisticFieldName=r||"convexHull");return p}_getStatisticValue(e,t,i,s){const{onStatisticField:a,statisticType:r}=e;let n=null;return n=null!=i&&i.has(a)?i.get(a):(0,y.isStringField)(this.fieldsIndex.get(a))?(0,x.calculateStringStatistics)({values:t,returnDistinct:s}):(0,x.calculateStatistics)({values:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(a,n),n["var"===r?"variance":r]}_getPercentileValue(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:a}=e,{value:r,orderBy:n}=s,o=this.fieldsIndex.get(i),l={value:r,orderBy:n,fieldType:null==o?void 0:o.type,isDiscrete:"percentile_disc"===a};return(0,x.calculatePercentile)(t,l)}_getAttributeValues(e,t,i){if(i.has(t))return i.get(t);const s=this.fieldsIndex.get(t),a=this.items.map((i=>e.getFieldValue(i,t,s)));return i.set(t,a),a}_getAttributeNormalizedValues(e,t){return this.items.map((i=>e.getNormalizedValue(i,{field:t.field,fieldInfo:this.fieldsIndex.get(t.field),normalizationField:t.normalizationField,normalizationFieldInfo:this.fieldsIndex.get(t.normalizationField),normalizationType:t.normalizationType,normalizationTotal:t.normalizationTotal})))}async _getAttributeExpressionValues(e,t,i){const{arcadeUtils:s}=await(0,_.loadArcade)(),a=s.createFunction(t),r=i&&s.getViewInfo(i);return this.items.map((t=>e.getExpressionValue(t,{compiledFunc:a,viewInfo:r},s)))}_calculateUniqueValues(e,t){const i={},s=this.items,a=s.length;for(let r=0;r<a;r++){const a=s[r],n=[];for(const t of e)n.push(t[r]);const o=n.join(",");t?null==i[o]&&(i[o]={count:1,data:n,items:[a],itemPositions:[r]}):null==i[o]?i[o]={count:1,data:n,items:[a],itemPositions:[r]}:(i[o].count++,i[o].items.push(a),i[o].itemPositions.push(r))}return i}async _getDataValues(e,t){const i=new(0,d.default)(e,this.featureAdapter,this.fieldsIndex),{valueExpression:s,field:a,normalizationField:r,normalizationType:n,normalizationTotal:o,scale:l}=t,u=s?{viewingMode:"map",scale:l,spatialReference:e.outSR||this.spatialReference}:null;return s?this._getAttributeExpressionValues(i,s,u):this._getAttributeNormalizedValues(i,{field:a,normalizationField:r,normalizationType:n,normalizationTotal:o})}constructor(e,t,i){this.items=e,this.queryGeometry=t,this.definitionExpression=i.definitionExpression,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.fieldsIndex=i.fieldsIndex,this.timeInfo=i.timeInfo,this.featureAdapter=i.featureAdapter,this.aggregateAdapter=i.aggregateAdapter}}function F(e,t,i,s,a,r){const n=a-i,o=r-s,l=n*n+o*o,u=(e-i)*n+(t-s)*o,c=Math.min(1,Math.max(0,u/l));return{x:i+n*c,y:s+o*c}}(r=a||(a={}))[r.NONE=0]="NONE",r[r.EDGE=1]="EDGE",r[r.VERTEX=2]="VERTEX"})),t.register("cWVjE",(function(i,s){e(i.exports,"default",(function(){return o}));var a=t("1CpCt"),r=t("7CVm9"),n=t("i3NJS");class o{countDistinctValues(e){return this.returnDistinctValues?(e.forEach((e=>this.getAttributes(e))),this._returnDistinctMap.size):e.length}getAttributes(e){const t=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(t)}getFieldValue(e,t,i){const s=i?i.name:t;let a=null;return this._fieldDataCache.has(s)?a=this._fieldDataCache.get(s).clause:i||(a=(0,r.getWhereClause)(t,this.fieldsIndex),this._fieldDataCache.set(s,{alias:s,clause:a})),i?this.featureAdapter.getAttribute(e,s):a.calculateValue(e,this.featureAdapter)}getNormalizedValue(e,t){const i=t.normalizationType,s=t.normalizationTotal;let a=this.getFieldValue(e,t.field,t.fieldInfo);if(i&&Number.isFinite(a)){const r=this.getFieldValue(e,t.normalizationField,t.normalizationFieldInfo);a=(0,n.getNormalizedValue)(a,i,r,s)}return a}getExpressionValue(e,t,i){const s={attributes:this.featureAdapter.getAttributes(e)},a=i.createExecContext(s,t.viewInfo);return i.executeFunction(t.compiledFunc,a)}validateItem(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:(0,r.getWhereClause)(t,this.fieldsIndex)}),this._fieldDataCache.get(t).clause.testFeature(e,this.featureAdapter)}validateItems(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:(0,r.getWhereClause)(t,this.fieldsIndex)}),this._fieldDataCache.get(t).clause.testSet(e,this.featureAdapter)}_processAttributesForOutFields(e){const t=this.outFields;if(!t||!t.length)return this.featureAdapter.getAttributes(e);const i={};for(const s of t){const{alias:t,clause:a}=this._fieldDataCache.get(s);i[t]=a?a.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,t)}return i}_processAttributesForDistinctValues(e){if((0,a.isNone)(e)||!this.returnDistinctValues)return e;const t=this.outFields,i=[];if(t)for(const s of t){const{alias:t}=this._fieldDataCache.get(s);i.push(e[t])}else for(const t in e)i.push(e[t]);const s=`${(t||["*"]).join(",")}=${i.join(",")}`;let r=this._returnDistinctMap.get(s)||0;return this._returnDistinctMap.set(s,++r),r>1?null:e}constructor(e,t,i){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues,this.fieldsIndex=i,this.featureAdapter=t;const s=e.outFields;if(s&&-1===s.indexOf("*")){this.outFields=s;let e=0;for(const t of s){const s=(0,r.getExpressionFromFieldName)(t),a=this.fieldsIndex.get(s),n=a?null:(0,r.getWhereClause)(s,i),o=a?a.name:(0,r.getAliasFromFieldName)(t)||"FIELD_EXP_"+e++;this._fieldDataCache.set(t,{alias:o,clause:n})}}}}})),t.register("jatML",(function(e,i){e.exports=Promise.all([import("./"+t("kyEFX").resolve("j9aC3")),import("./"+t("kyEFX").resolve("amzcH"))]).then((()=>t("d26pv")))})),t.register("kyEFX",(function(t,i){var s,a;e(t.exports,"register",(function(){return s}),(function(e){return s=e})),e(t.exports,"resolve",(function(){return a}),(function(e){return a=e}));var r={};s=function(e){for(var t=Object.keys(e),i=0;i<t.length;i++)r[t[i]]=e[t[i]]},a=function(e){var t=r[e];if(null==t)throw new Error("Could not resolve bundle with id "+e);return t}}));
//# sourceMappingURL=CSVSourceWorker.b24e2ecb.js.map
