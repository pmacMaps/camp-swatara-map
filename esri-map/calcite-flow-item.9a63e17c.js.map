{"mappings":"4hBAKA,IAAAA,EAAAC,EAAA,S,uCAKA,SAASC,EAAaC,GACpB,OAAOA,EAAUC,MAAM,KAAK,E,CAG9B,SAASC,EAAkBC,GACzB,MAAgB,MAATA,EAAe,SAAW,O,CAGnC,SAASC,EAAQJ,GACf,OAAOA,EAAUC,MAAM,KAAK,E,CAG9B,SAASI,EAAyBL,GAChC,MAAO,CAAC,MAAO,UAAUM,SAASF,EAAQJ,IAAc,IAAM,G,CAGhE,SAASO,EAA2BC,EAAMR,EAAWS,GACnD,IAAIC,UACFA,EAASC,SACTA,GACEH,EACJ,MAAMI,EAAUF,EAAUG,EAAIH,EAAUI,MAAQ,EAAIH,EAASG,MAAQ,EAC/DC,EAAUL,EAAUM,EAAIN,EAAUO,OAAS,EAAIN,EAASM,OAAS,EACjEC,EAAWb,EAAyBL,GACpCmB,EAASjB,EAAkBgB,GAC3BE,EAAcV,EAAUS,GAAU,EAAIR,EAASQ,GAAU,EAEzDE,EAA0B,MAAbH,EACnB,IAAII,EACJ,OAHalB,EAAQJ,IAInB,IAAK,MACHsB,EAAS,CACPT,EAAGD,EACHI,EAAGN,EAAUM,EAAIL,EAASM,QAE5B,MACF,IAAK,SACHK,EAAS,CACPT,EAAGD,EACHI,EAAGN,EAAUM,EAAIN,EAAUO,QAE7B,MACF,IAAK,QACHK,EAAS,CACPT,EAAGH,EAAUG,EAAIH,EAAUI,MAC3BE,EAAGD,GAEL,MACF,IAAK,OACHO,EAAS,CACPT,EAAGH,EAAUG,EAAIF,EAASG,MAC1BE,EAAGD,GAEL,MACF,QACEO,EAAS,CACPT,EAAGH,EAAUG,EACbG,EAAGN,EAAUM,GAGnB,OAAQjB,EAAaC,IACnB,IAAK,QACHsB,EAAOJ,IAAaE,GAAeX,GAAOY,GAAa,EAAK,GAC5D,MACF,IAAK,MACHC,EAAOJ,IAAaE,GAAeX,GAAOY,GAAa,EAAK,GAGhE,OAAOC,C,CA+FT,SAASC,EAASC,EAAOC,GACvB,MAAwB,mBAAVD,EAAuBA,EAAMC,GAASD,C,CAatD,SAASE,EAAyBC,GAChC,MAA0B,iBAAZA,EAXhB,SAA6BA,GAC3B,MAAO,CACLC,IAAK,EACLC,MAAO,EACPC,OAAQ,EACRC,KAAM,KACHJ,E,CAKgCK,CAAoBL,GAAW,CAClEC,IAAKD,EACLE,MAAOF,EACPG,OAAQH,EACRI,KAAMJ,E,CAIV,SAASM,EAAiBC,GACxB,MAAO,IACFA,EACHN,IAAKM,EAAKlB,EACVe,KAAMG,EAAKrB,EACXgB,MAAOK,EAAKrB,EAAIqB,EAAKpB,MACrBgB,OAAQI,EAAKlB,EAAIkB,EAAKjB,O,CAY1BkB,eAAeC,EAAeC,EAAOC,GACnC,IAAIC,OACY,IAAZD,IACFA,EAAU,IAEZ,MAAMzB,EACJA,EAACG,EACDA,EAACwB,SACDA,EAAQC,MACRA,EAAKC,SACLA,EAAQC,SACRA,GACEN,GACEO,SACJA,EAAW,oBAAmBC,aAC9BA,EAAe,WAAUC,eACzBA,EAAiB,WAAUC,YAC3BA,GAAc,EAAKpB,QACnBA,EAAU,GACRJ,EAASe,EAASD,GAChBW,EAAgBtB,EAAyBC,GAEzCsB,EAAUP,EAASK,EADa,aAAnBD,EAAgC,YAAc,WACbA,GAC9CI,EAAqBjB,QAAuBO,EAASW,gBAAgB,CACzEF,QAAiH,OAAtGV,QAAqD,MAAtBC,EAASY,eAAoB,EAASZ,EAASY,UAAUH,MAAqBV,EAAgCU,EAAUA,EAAQI,sBAAyD,MAA/Bb,EAASc,wBAA6B,EAASd,EAASc,mBAAmBZ,EAAS/B,W,SACxRiC,E,aACAC,E,SACAF,KAEIT,EAA0B,aAAnBY,EAAgC,IACxCL,EAAM9B,S,EACTE,E,EACAG,GACEyB,EAAM/B,UACJ6C,QAAkD,MAA5Bf,EAASgB,qBAA0B,EAAShB,EAASgB,gBAAgBd,EAAS/B,WACpG8C,QAA4C,MAAtBjB,EAASY,eAAoB,EAASZ,EAASY,UAAUG,WAA+C,MAArBf,EAASkB,cAAmB,EAASlB,EAASkB,SAASH,KAGlK,CACF1C,EAAG,EACHG,EAAG,GAEC2C,EAAoB1B,EAAiBO,EAASoB,4DAA8DpB,EAASoB,sDAAsD,C,KAC/K1B,E,aACAqB,E,SACAZ,IACGT,GACL,MAAO,CACLN,KAAMsB,EAAmBtB,IAAM+B,EAAkB/B,IAAMoB,EAAcpB,KAAO6B,EAAYzC,EACxFc,QAAS6B,EAAkB7B,OAASoB,EAAmBpB,OAASkB,EAAclB,QAAU2B,EAAYzC,EACpGe,MAAOmB,EAAmBnB,KAAO4B,EAAkB5B,KAAOiB,EAAcjB,MAAQ0B,EAAY5C,EAC5FgB,OAAQ8B,EAAkB9B,MAAQqB,EAAmBrB,MAAQmB,EAAcnB,OAAS4B,EAAY5C,E,CAIpG,MAAMgD,EAAQC,KAAKC,IACbC,EAAQF,KAAKG,IAEnB,SAASC,EAAOC,EAAS3C,EAAO4C,GAC9B,OAAOJ,EAAMG,EAASN,EAAMrC,EAAO4C,G,CAQrC,MAwEMC,EAAQ,CAAC,MAAO,QAAS,SAAU,QACnCC,EAA6BD,EAAME,QAAO,CAACC,EAAKC,IAASD,EAAIE,OAAOD,EAAMA,EAAO,SAAUA,EAAO,SAAS,IAE3GE,EAAkB,CACtB5C,KAAM,QACNF,MAAO,OACPC,OAAQ,MACRF,IAAK,UAEP,SAASgD,EAAqB5E,GAC5B,OAAOA,EAAU6E,QAAO,0BAA2BJ,GAAQE,EAAgBF,I,CAG7E,SAASK,EAAkB9E,EAAWyC,EAAOhC,QAC/B,IAARA,IACFA,GAAM,GAER,MAAMsE,EAAYhF,EAAaC,GACzBkB,EAAWb,EAAyBL,GACpCmB,EAASjB,EAAkBgB,GACjC,IAAI8D,EAAiC,MAAb9D,EAAmB6D,KAAetE,EAAM,MAAQ,SAAW,QAAU,OAAuB,UAAdsE,EAAwB,SAAW,MAIzI,OAHItC,EAAM/B,UAAUS,GAAUsB,EAAM9B,SAASQ,KAC3C6D,EAAoBJ,EAAqBI,IAEpC,CACLC,KAAMD,EACNE,MAAON,EAAqBI,G,CAIhC,MAAMG,EAAuB,CAC3BC,MAAO,MACPC,IAAK,SAEP,SAASC,EAA8BtF,GACrC,OAAOA,EAAU6E,QAAO,cAAeE,GAAaI,EAAqBJ,I,CAkB3E,MAAMQ,EAAgB,SAAUjD,GAI9B,YAHgB,IAAZA,IACFA,EAAU,IAEL,CACLkD,KAAM,gB,QACNlD,EACAH,SAASE,GACP,IAAIoD,EAAuBC,EAAwBC,EACnD,MAAMlD,MACJA,EAAKmD,eACLA,EAAc5F,UACdA,EAASwC,SACTA,EAAQE,SACRA,GACEL,GACEwD,UACJA,GAAY,EAAKd,UACjBA,EAASe,kBACTA,EAAoBxB,EAAayB,cACjCA,GAAgB,KACbC,GACDzE,EAASe,EAASD,GAChB4D,OAA2BC,IAAdnB,GAA2Be,IAAsBxB,EAtC1E,SAA0BS,EAAWgB,EAAeD,GAElD,OAD2Cf,EAAY,IAAIe,EAAkBK,QAAOnG,GAAaD,EAAaC,KAAe+E,OAAee,EAAkBK,QAAOnG,GAAaD,EAAaC,KAAe+E,KAAce,EAAkBK,QAAOnG,GAAaI,EAAQJ,KAAeA,KAC/OmG,QAAOnG,IAC3C+E,GACKhF,EAAaC,KAAe+E,KAAcgB,GAAgBT,EAA8BtF,KAAeA,G,CAkC1BoG,CAAiBrB,GAAa,KAAMgB,EAAeD,GAAqBA,EACtJO,QAAiBjE,EAAeC,EAAO2D,GACvCM,GAA0E,OAAzDb,EAAwBG,EAAeW,oBAAyB,EAASd,EAAsBe,QAAU,EAC1HC,EAAmBR,EAAWK,GACpC,GAAwB,MAApBG,EACF,MAAO,GAET,MAAMxB,KACJA,EAAIC,MACJA,GACEJ,EAAkB2B,EAAkBhE,QAAgC,MAAlBD,EAASkE,WAAgB,EAASlE,EAASkE,MAAMhE,EAAS/B,YAGhH,GAAIX,IAAcyG,EAChB,MAAO,CACLE,MAAO,CACL3G,UAAWiG,EAAW,KAI5B,MAAMW,EAAmB,CAACP,EAASjG,EAAQqG,IAAoBJ,EAASpB,GAAOoB,EAASnB,IAClF2B,EAAe,KAAiE,OAA1DnB,EAAyBE,EAAeW,oBAAyB,EAASb,EAAuBoB,YAAc,GAAK,CAC9I9G,UAAWyG,EACXK,UAAWF,IAEPG,EAAgBd,EAAWK,EAAe,GAGhD,GAAIS,EACF,MAAO,CACLC,KAAM,CACJR,MAAOF,EAAe,EACtBQ,UAAWD,GAEbF,MAAO,CACL3G,UAAW+G,IAIjB,MAAME,EAA8BJ,EAAaK,KAAIC,IACnD,MAAMpC,EAAYhF,EAAaoH,EAAEnH,WACjC,MAAO,CAACmH,EAAEnH,UAAW+E,GAAac,EAElCsB,EAAEL,UAAUM,MAAM,EAAG,GAAG7C,QAAO,CAACC,EAAK6C,IAAM7C,EAAM6C,GAAG,GAEpDF,EAAEL,UAAU,GAAIK,EAAEL,UAAU,IAC3BQ,MAAK,CAACC,EAAGC,IAAMD,EAAE,GAAKC,EAAE,KAKrBC,GAA8E,OAA3D9B,EAJWsB,EAA4Bd,QAAOgB,GAAKA,EAAE,GAAGC,MAAM,EAGvFrH,EAAaoH,EAAE,IAAM,EAAI,GAAGO,OAAML,GAAKA,GAAK,MACiC,SAAc,EAAS1B,EAAsB,KAAOsB,EAA4B,GAAG,GAChK,OAAIQ,IAAmBzH,EACd,CACLgH,KAAM,CACJR,MAAOF,EAAe,EACtBQ,UAAWD,GAEbF,MAAO,CACL3G,UAAWyH,IAIV,E,IA6Cb,MAAME,EAAO,SAAUrF,GAIrB,YAHgB,IAAZA,IACFA,EAAU,IAEL,CACLkD,KAAM,O,QACNlD,EACAH,SAASE,GACP,IAAIuF,EACJ,MAAM5H,UACJA,EAAS4F,eACTA,EAAcnD,MACdA,EAAKoF,iBACLA,EAAgBrF,SAChBA,EAAQE,SACRA,GACEL,GAEFnB,SAAU4G,GAAgB,EAC1BjC,UAAWkC,GAAiB,EAC5BC,mBAAoBC,EAA2BC,iBAC/CA,EAAmB,UAASC,0BAC5BA,EAA4B,OAAMC,cAClCA,GAAgB,KACbpC,GACDzE,EAASe,EAASD,GAChBoC,EAAOrE,EAAQJ,GACfqI,EAAkBjI,EAAQyH,KAAsBA,EAChDpH,QAA+B,MAAlB+B,EAASkE,WAAgB,EAASlE,EAASkE,MAAMhE,EAAS/B,WACvEqH,EAAqBC,IAAgCI,IAAoBD,EAAgB,CAACxD,EAAqBiD,IArE3H,SAA+B7H,GAC7B,MAAMsI,EAAoB1D,EAAqB5E,GAC/C,MAAO,CAACsF,EAA8BtF,GAAYsI,EAAmBhD,EAA8BgD,G,CAmE2CC,CAAsBV,IAC3JI,GAA6D,SAA9BE,GAClCH,EAAmBQ,QAjD3B,SAAmCxI,EAAWoI,EAAeK,EAAWhI,GACtE,MAAMsE,EAAYhF,EAAaC,GAC/B,IAAI0I,EAnBN,SAAqBjE,EAAMkE,EAASlI,GAClC,MAAMmI,EAAK,CAAC,OAAQ,SACdC,EAAK,CAAC,QAAS,QACfC,EAAK,CAAC,MAAO,UACbC,EAAK,CAAC,SAAU,OACtB,OAAQtE,GACN,IAAK,MACL,IAAK,SACH,OAAIhE,EAAYkI,EAAUE,EAAKD,EACxBD,EAAUC,EAAKC,EACxB,IAAK,OACL,IAAK,QACH,OAAOF,EAAUG,EAAKC,EACxB,QACE,MAAO,G,CAKAC,CAAY5I,EAAQJ,GAA0B,UAAdyI,EAAuBhI,GAOlE,OANIsE,IACF2D,EAAOA,EAAKxB,KAAIzC,GAAQA,EAAO,IAAMM,IACjCqD,IACFM,EAAOA,EAAKhE,OAAOgE,EAAKxB,IAAI5B,MAGzBoD,C,CAwC0BO,CAA0BpB,EAAkBO,EAAeD,EAA2B1H,IAEnH,MAAMwF,EAAa,CAAC4B,KAAqBG,GACnC3B,QAAiBjE,EAAeC,EAAO2D,GACvCc,EAAY,GAClB,IAAIoC,GAAiE,OAA/CtB,EAAuBhC,EAAeuD,WAAgB,EAASvB,EAAqBd,YAAc,GAIxH,GAHIgB,GACFhB,EAAU0B,KAAKnC,EAAS5B,IAEtBsD,EAAgB,CAClB,MAAM9C,KACJA,EAAIC,MACJA,GACEJ,EAAkB9E,EAAWyC,EAAOhC,GACxCqG,EAAU0B,KAAKnC,EAASpB,GAAOoB,EAASnB,G,CAQ1C,GANAgE,EAAgB,IAAIA,EAAe,C,UACjClJ,E,UACA8G,KAIGA,EAAUY,OAAMjD,GAAQA,GAAQ,IAAI,CACvC,IAAI2E,EAAuBC,EAC3B,MAAMC,IAA+D,OAAhDF,EAAwBxD,EAAeuD,WAAgB,EAASC,EAAsB5C,QAAU,GAAK,EACpHO,EAAgBd,EAAWqD,GACjC,GAAIvC,EAEF,MAAO,CACLC,KAAM,CACJR,MAAO8C,EACPxC,UAAWoC,GAEbvC,MAAO,CACL3G,UAAW+G,IAOjB,IAAIU,EAAgJ,OAA9H4B,EAAwBH,EAAc/C,QAAOgB,GAAKA,EAAEL,UAAU,IAAM,IAAGQ,MAAK,CAACC,EAAGC,IAAMD,EAAET,UAAU,GAAKU,EAAEV,UAAU,KAAI,SAAc,EAASuC,EAAsBrJ,UAG1L,IAAKyH,EACH,OAAQS,GACN,IAAK,UACH,CACE,IAAIqB,EACJ,MAAMC,EAAyM,OAA5LD,EAAwBL,EAAchC,KAAIC,GAAK,CAACA,EAAEnH,UAAWmH,EAAEL,UAAUX,QAAOE,GAAYA,EAAW,IAAG9B,QAAO,CAACC,EAAK6B,IAAa7B,EAAM6B,GAAU,MAAKiB,MAAK,CAACC,EAAGC,IAAMD,EAAE,GAAKC,EAAE,KAAI,SAAc,EAAS+B,EAAsB,GACjPC,IACF/B,EAAiB+B,GAEnB,K,CAEJ,IAAK,mBACH/B,EAAiBI,EAIvB,GAAI7H,IAAcyH,EAChB,MAAO,CACLd,MAAO,CACL3G,UAAWyH,G,CAKnB,MAAO,E,IAKb,SAASgC,EAAepD,EAAUnE,GAChC,MAAO,CACLN,IAAKyE,EAASzE,IAAMM,EAAKjB,OACzBY,MAAOwE,EAASxE,MAAQK,EAAKpB,MAC7BgB,OAAQuE,EAASvE,OAASI,EAAKjB,OAC/Bc,KAAMsE,EAAStE,KAAOG,EAAKpB,M,CAG/B,SAAS4I,EAAsBrD,GAC7B,OAAOhC,EAAMsF,MAAKlF,GAAQ4B,EAAS5B,IAAS,G,CAO9C,MAAMmF,EAAO,SAAUtH,GAIrB,YAHgB,IAAZA,IACFA,EAAU,IAEL,CACLkD,KAAM,O,QACNlD,EACAH,SAASE,GACP,MAAMI,MACJA,GACEJ,GACEM,SACJA,EAAW,qBACRqD,GACDzE,EAASe,EAASD,GACtB,OAAQM,GACN,IAAK,kBACH,CACE,MAIMkH,EAAUJ,QAJOrH,EAAeC,EAAO,IACxC2D,EACHlD,eAAgB,cAEuBL,EAAM/B,WAC/C,MAAO,CACLsG,KAAM,CACJ8C,uBAAwBD,EACxBE,gBAAiBL,EAAsBG,I,CAI/C,IAAK,UACH,CACE,MAIMG,EAAUP,QAJOrH,EAAeC,EAAO,IACxC2D,EACHjD,aAAa,IAE0BN,EAAM9B,UAC/C,MAAO,CACLqG,KAAM,CACJiD,eAAgBD,EAChBE,QAASR,EAAsBM,I,CAIvC,QAEI,MAAO,G,IAuDnB,MAAMG,EAAS,SAAU7H,GAIvB,YAHgB,IAAZA,IACFA,EAAU,GAEL,CACLkD,KAAM,S,QACNlD,EACAH,SAASE,GACP,MAAMxB,EACJA,EAACG,EACDA,GACEqB,EACE+H,QA5DZjI,eAAoCE,EAAOC,GACzC,MAAMtC,UACJA,EAASwC,SACTA,EAAQE,SACRA,GACEL,EACE5B,QAA+B,MAAlB+B,EAASkE,WAAgB,EAASlE,EAASkE,MAAMhE,EAAS/B,WACvE8D,EAAOrE,EAAQJ,GACf+E,EAAYhF,EAAaC,GACzBqB,EAAqD,MAAxChB,EAAyBL,GACtCqK,EAAgB,CAAC,OAAQ,OAAO/J,SAASmE,IAAQ,EAAK,EACtD6F,EAAiB7J,GAAOY,GAAa,EAAK,EAC1CkJ,EAAWhJ,EAASe,EAASD,GAGnC,IAAInB,SACFA,EAAQ2E,UACRA,EAAS2E,cACTA,GACsB,iBAAbD,EAAwB,CACjCrJ,SAAUqJ,EACV1E,UAAW,EACX2E,cAAe,MACb,CACFtJ,SAAU,EACV2E,UAAW,EACX2E,cAAe,QACZD,GAKL,OAHIxF,GAAsC,iBAAlByF,IACtB3E,EAA0B,QAAdd,GAAsC,EAAhByF,EAAqBA,GAElDnJ,EAAa,CAClBR,EAAGgF,EAAYyE,EACftJ,EAAGE,EAAWmJ,GACZ,CACFxJ,EAAGK,EAAWmJ,EACdrJ,EAAG6E,EAAYyE,E,CAuBYG,CAAqBpI,EAAOC,GACrD,MAAO,CACLzB,EAAGA,EAAIuJ,EAAWvJ,EAClBG,EAAGA,EAAIoJ,EAAWpJ,EAClBgG,KAAMoD,E,IAoFd,SAASM,EAAUC,GACjB,IAAIC,EACJ,OAAsD,OAA7CA,EAAsBD,EAAKE,oBAAyB,EAASD,EAAoBE,cAAgBC,M,CAG5G,SAASC,EAAmB/H,GAC1B,OAAOyH,EAAUzH,GAASgI,iBAAiBhI,E,CAG7C,SAASiI,EAAO1J,GACd,OAAOA,aAAiBkJ,EAAUlJ,GAAO2J,I,CAE3C,SAASC,EAAYT,GACnB,OAAIO,EAAOP,IACDA,EAAKU,UAAY,IAAIC,cAKxB,W,CAGT,SAASC,EAAc/J,GACrB,OAAOA,aAAiBkJ,EAAUlJ,GAAOgK,W,CAE3C,SAASC,EAAUjK,GACjB,OAAOA,aAAiBkJ,EAAUlJ,GAAOkK,O,CAE3C,SAASC,EAAahB,GAEpB,MAA0B,oBAAfiB,aAGJjB,aAAgBD,EAAUC,GAAMiB,YAAcjB,aAAgBiB,W,CAEvE,SAASC,EAAkB5I,GACzB,MAAMoD,SACJA,EAAQyF,UACRA,EAASC,UACTA,EAASC,QACTA,GACEhB,EAAmB/H,GACvB,MAAO,kCAAkCgJ,KAAK5F,EAAW0F,EAAYD,KAAe,CAAC,SAAU,YAAYxL,SAAS0L,E,CAEtH,SAASE,EAAejJ,GACtB,MAAO,CAAC,QAAS,KAAM,MAAM3C,SAAS8K,EAAYnI,G,CAEpD,SAASkJ,EAAkBlJ,GACzB,MAAMmJ,EAASC,IACTC,EAAMtB,EAAmB/H,GAG/B,MAAyB,SAAlBqJ,EAAIC,WAA4C,SAApBD,EAAIE,cAA2BJ,KAAWE,EAAIG,gBAAwC,SAAvBH,EAAIG,iBAAuCL,KAAWE,EAAInG,QAAwB,SAAfmG,EAAInG,QAA8B,CAAC,YAAa,cAAe,UAAUwD,MAAKnI,IAAU8K,EAAII,YAAc,IAAIpM,SAASkB,MAAW,CAAC,QAAS,SAAU,SAAU,WAAWmI,MAAKnI,IAAU8K,EAAIK,SAAW,IAAIrM,SAASkB,I,CAE7X,SAAS6K,IACP,QAAmB,oBAARO,MAAwBA,IAAIC,WAChCD,IAAIC,SAAS,0BAA2B,O,CAEjD,SAASC,EAAsBnC,GAC7B,MAAO,CAAC,OAAQ,OAAQ,aAAarK,SAAS8K,EAAYT,G,CAG5D,MAAMoC,EAAMjJ,KAAKC,IACXiJ,EAAMlJ,KAAKG,IACXgJ,EAAQnJ,KAAKoJ,MACbC,EAAQrJ,KAAKsJ,MACbC,EAAoBhG,IAAM,CAC9BxG,EAAGwG,EACHrG,EAAGqG,IAGL,SAASiG,EAAiBrK,GACxB,MAAMqJ,EAAMtB,EAAmB/H,GAG/B,IAAInC,EAAQyM,WAAWjB,EAAIxL,QAAU,EACjCG,EAASsM,WAAWjB,EAAIrL,SAAW,EACvC,MAAMuM,EAAYjC,EAActI,GAC1BwK,EAAcD,EAAYvK,EAAQwK,YAAc3M,EAChD4M,EAAeF,EAAYvK,EAAQyK,aAAezM,EAClD0M,EAAiBV,EAAMnM,KAAW2M,GAAeR,EAAMhM,KAAYyM,EAKzE,OAJIC,IACF7M,EAAQ2M,EACRxM,EAASyM,GAEJ,C,MACL5M,E,OACAG,EACA2M,EAAGD,E,CAIP,SAASE,EAAc5K,GACrB,OAAQwI,EAAUxI,GAAoCA,EAAzBA,EAAQI,c,CAGvC,SAASyK,EAAS7K,GAChB,MAAM8K,EAAaF,EAAc5K,GACjC,IAAKsI,EAAcwC,GACjB,OAAOV,EAAkB,GAE3B,MAAMnL,EAAO6L,EAAWC,yBAClBlN,MACJA,EAAKG,OACLA,EAAM2M,EACNA,GACEN,EAAiBS,GACrB,IAAIlN,GAAK+M,EAAIX,EAAM/K,EAAKpB,OAASoB,EAAKpB,OAASA,EAC3CE,GAAK4M,EAAIX,EAAM/K,EAAKjB,QAAUiB,EAAKjB,QAAUA,EAUjD,OANKJ,GAAMoN,OAAOC,SAASrN,KACzBA,EAAI,GAEDG,GAAMiN,OAAOC,SAASlN,KACzBA,EAAI,GAEC,C,EACLH,E,EACAG,E,CAIJ,MAAMmN,EAAyBd,EAAkB,GACjD,SAASe,GAAiBnL,EAASoL,EAASC,GAC1C,IAAIC,EAAqBC,EAIzB,QAHgB,IAAZH,IACFA,GAAU,IAEPhC,IACH,OAAO8B,EAET,MAAMM,EAAMxL,EAAUyH,EAAUzH,GAAW8H,OAC3C,OAAKuD,GAAwBD,GAAWC,IAAyBG,EACxDN,EAEF,CACLtN,GAAkD,OAA7C0N,EAAsBE,EAAIC,qBAA0B,EAASH,EAAoBI,aAAe,EACrG3N,GAAmD,OAA9CwN,EAAuBC,EAAIC,qBAA0B,EAASF,EAAqBI,YAAc,E,CAI1G,SAASC,GAAsB5L,EAAS6L,EAAcC,EAAiBxL,QAChD,IAAjBuL,IACFA,GAAe,QAEO,IAApBC,IACFA,GAAkB,GAEpB,MAAMC,EAAa/L,EAAQ+K,wBACrBD,EAAaF,EAAc5K,GACjC,IAAIgM,EAAQ5B,EAAkB,GAC1ByB,IACEvL,EACEkI,EAAUlI,KACZ0L,EAAQnB,EAASvK,IAGnB0L,EAAQnB,EAAS7K,IAGrB,MAAMiM,EAAgBd,GAAiBL,EAAYgB,EAAiBxL,GACpE,IAAI1C,GAAKmO,EAAWjN,KAAOmN,EAAcrO,GAAKoO,EAAMpO,EAChDG,GAAKgO,EAAWpN,IAAMsN,EAAclO,GAAKiO,EAAMjO,EAC/CF,EAAQkO,EAAWlO,MAAQmO,EAAMpO,EACjCI,EAAS+N,EAAW/N,OAASgO,EAAMjO,EACvC,GAAI+M,EAAY,CACd,MAAMU,EAAM/D,EAAUqD,GAChBoB,EAAY5L,GAAgBkI,EAAUlI,GAAgBmH,EAAUnH,GAAgBA,EACtF,IAAI6L,EAAgBX,EAAIY,aACxB,KAAOD,GAAiB7L,GAAgB4L,IAAcV,GAAK,CACzD,MAAMa,EAAcxB,EAASsB,GACvBG,EAAaH,EAAcpB,wBAC3B1B,EAAMrB,iBAAiBmE,GACvBrN,EAAOwN,EAAWxN,MAAQqN,EAAcI,WAAajC,WAAWjB,EAAImD,cAAgBH,EAAYzO,EAChGe,EAAM2N,EAAW3N,KAAOwN,EAAcM,UAAYnC,WAAWjB,EAAIqD,aAAeL,EAAYtO,EAClGH,GAAKyO,EAAYzO,EACjBG,GAAKsO,EAAYtO,EACjBF,GAASwO,EAAYzO,EACrBI,GAAUqO,EAAYtO,EACtBH,GAAKkB,EACLf,GAAKY,EACLwN,EAAgB1E,EAAU0E,GAAeC,Y,EAG7C,OAAOpN,EAAiB,C,MACtBnB,E,OACAG,E,EACAJ,E,EACAG,G,CAIJ,SAAS4O,GAAmBjF,GAC1B,QAASO,EAAOP,GAAQA,EAAKE,cAAgBF,EAAKkF,WAAa9E,OAAO8E,UAAUC,e,CAGlF,SAASC,GAAc9M,GACrB,OAAIwI,EAAUxI,GACL,CACL+M,WAAY/M,EAAQ+M,WACpBC,UAAWhN,EAAQgN,WAGhB,CACLD,WAAY/M,EAAQiN,YACpBD,UAAWhN,EAAQkN,Y,CAwCvB,SAASC,GAAoBnN,GAG3B,OAAO4L,GAAsBe,GAAmB3M,IAAUlB,KAAOgO,GAAc9M,GAAS+M,U,CAwB1F,SAASK,GAAc1F,GACrB,GAA0B,SAAtBS,EAAYT,GACd,OAAOA,EAET,MAAM2F,EAEN3F,EAAK4F,cAEL5F,EAAK6F,YAEL7E,EAAahB,IAASA,EAAK8F,MAE3Bb,GAAmBjF,GACnB,OAAOgB,EAAa2E,GAAUA,EAAOG,KAAOH,C,CAG9C,SAASI,GAA2B/F,GAClC,MAAM6F,EAAaH,GAAc1F,GACjC,OAAImC,EAAsB0D,GACjB7F,EAAKE,cAAgBF,EAAKE,cAAc8F,KAAOhG,EAAKgG,KAEzDpF,EAAciF,IAAe3E,EAAkB2E,GAC1CA,EAEFE,GAA2BF,E,CAGpC,SAASI,GAAqBjG,EAAMjC,GAClC,IAAIkC,OACS,IAATlC,IACFA,EAAO,IAET,MAAMmI,EAAqBH,GAA2B/F,GAChDmG,EAASD,KAAsE,OAA7CjG,EAAsBD,EAAKE,oBAAyB,EAASD,EAAoB+F,MACnHlC,EAAM/D,EAAUmG,GACtB,OAAIC,EACKpI,EAAKhE,OAAO+J,EAAKA,EAAIC,gBAAkB,GAAI7C,EAAkBgF,GAAsBA,EAAqB,IAE1GnI,EAAKhE,OAAOmM,EAAoBD,GAAqBC,G,CA6C9D,SAASE,GAAkC9N,EAAS+N,EAAkBrO,GACpE,IAAIT,EACJ,GAAyB,aAArB8O,EACF9O,EA7CJ,SAAyBe,EAASN,GAChC,MAAM8L,EAAM/D,EAAUzH,GAChBgO,EAAOrB,GAAmB3M,GAC1ByL,EAAiBD,EAAIC,eAC3B,IAAI5N,EAAQmQ,EAAKC,YACbjQ,EAASgQ,EAAKE,aACdtQ,EAAI,EACJG,EAAI,EACR,GAAI0N,EAAgB,CAClB5N,EAAQ4N,EAAe5N,MACvBG,EAASyN,EAAezN,OACxB,MAAMmQ,EAAsB/E,MACvB+E,GAAuBA,GAAoC,UAAbzO,KACjD9B,EAAI6N,EAAeC,WACnB3N,EAAI0N,EAAeE,U,CAGvB,MAAO,C,MACL9N,E,OACAG,E,EACAJ,E,EACAG,E,CAwBOqQ,CAAgBpO,EAASN,QAC3B,GAAyB,aAArBqO,EACT9O,EA3GJ,SAAyBe,GACvB,MAAMgO,EAAOrB,GAAmB3M,GAC1BqO,EAASvB,GAAc9M,GACvB0N,EAAO1N,EAAQ4H,cAAc8F,KAC7B7P,EAAQkM,EAAIiE,EAAKM,YAAaN,EAAKC,YAAaP,EAAKY,YAAaZ,EAAKO,aACvEjQ,EAAS+L,EAAIiE,EAAKO,aAAcP,EAAKE,aAAcR,EAAKa,aAAcb,EAAKQ,cACjF,IAAItQ,GAAKyQ,EAAOtB,WAAaI,GAAoBnN,GACjD,MAAMjC,GAAKsQ,EAAOrB,UAIlB,MAH2C,QAAvCjF,EAAmB2F,GAAMlI,YAC3B5H,GAAKmM,EAAIiE,EAAKC,YAAaP,EAAKO,aAAepQ,GAE1C,C,MACLA,E,OACAG,E,EACAJ,E,EACAG,E,CA4FOyQ,CAAgB7B,GAAmB3M,SACrC,GAAIwI,EAAUuF,GACnB9O,EAvBJ,SAAoCe,EAASN,GAC3C,MAAMqM,EAAaH,GAAsB5L,GAAS,EAAmB,UAAbN,GAClDf,EAAMoN,EAAWpN,IAAMqB,EAAQyM,UAC/B3N,EAAOiN,EAAWjN,KAAOkB,EAAQuM,WACjCP,EAAQ1D,EAActI,GAAW6K,EAAS7K,GAAWoK,EAAkB,GAK7E,MAAO,C,MAJOpK,EAAQiO,YAAcjC,EAAMpO,E,OAC3BoC,EAAQkO,aAAelC,EAAMjO,E,EAClCe,EAAOkN,EAAMpO,E,EACbe,EAAMqN,EAAMjO,E,CAeb0Q,CAA2BV,EAAkBrO,OAC/C,CACL,MAAMuM,EAAgBd,GAAiBnL,GACvCf,EAAO,IACF8O,EACHnQ,EAAGmQ,EAAiBnQ,EAAIqO,EAAcrO,EACtCG,EAAGgQ,EAAiBhQ,EAAIkO,EAAclO,E,CAG1C,OAAOiB,EAAiBC,E,CAE1B,SAASyP,GAAyB1O,EAAS2O,GACzC,MAAMpB,EAAaH,GAAcpN,GACjC,QAAIuN,IAAeoB,IAAanG,EAAU+E,IAAe1D,EAAsB0D,MAG5B,UAA5CxF,EAAmBwF,GAAYqB,UAAwBF,GAAyBnB,EAAYoB,G,CAqErG,SAASE,GAAoB7O,EAAS8O,GACpC,OAAKxG,EAActI,IAAqD,UAAzC+H,EAAmB/H,GAAS4O,SAGvDE,EACKA,EAAS9O,GAEXA,EAAQM,aALN,I,CAqBX,SAASyO,GAAgB/O,EAAS8O,GAChC,MAAME,EAASvH,EAAUzH,GACzB,IAAKsI,EAActI,GACjB,OAAOgP,EAET,IAAI1O,EAAeuO,GAAoB7O,EAAS8O,GAChD,KAAOxO,GAAgB2I,EAAe3I,IAA+D,WAA9CyH,EAAmBzH,GAAcsO,UACtFtO,EAAeuO,GAAoBvO,EAAcwO,GAEnD,OAAIxO,IAA+C,SAA9B6H,EAAY7H,IAA0D,SAA9B6H,EAAY7H,IAA0E,WAA9CyH,EAAmBzH,GAAcsO,WAA0B1F,EAAkB5I,IACzK0O,EAEF1O,GA1BT,SAA4BN,GAC1B,IAAIiP,EAAc7B,GAAcpN,GAChC,KAAOsI,EAAc2G,KAAiBpF,EAAsBoF,IAAc,CACxE,GAAI/F,EAAkB+F,GACpB,OAAOA,EAEPA,EAAc7B,GAAc6B,E,CAGhC,OAAO,I,CAiBgBC,CAAmBlP,IAAYgP,C,CAGxD,SAASG,GAA8BnP,EAASM,EAAcZ,GAC5D,MAAM0P,EAA0B9G,EAAchI,GACxCuM,EAAkBF,GAAmBrM,GACrC8K,EAAuB,UAAb1L,EACVT,EAAO2M,GAAsB5L,GAAS,EAAMoL,EAAS9K,GAC3D,IAAI+N,EAAS,CACXtB,WAAY,EACZC,UAAW,GAEb,MAAMpG,EAAUwD,EAAkB,GAClC,GAAIgF,IAA4BA,IAA4BhE,EAI1D,IAHkC,SAA9BjD,EAAY7H,IAA4BsI,EAAkBiE,MAC5DwB,EAASvB,GAAcxM,IAErBgI,EAAchI,GAAe,CAC/B,MAAM+O,EAAazD,GAAsBtL,GAAc,EAAM8K,EAAS9K,GACtEsG,EAAQhJ,EAAIyR,EAAWzR,EAAI0C,EAAaiM,WACxC3F,EAAQ7I,EAAIsR,EAAWtR,EAAIuC,EAAamM,S,MAC/BI,IACTjG,EAAQhJ,EAAIuP,GAAoBN,IAGpC,MAAO,CACLjP,EAAGqB,EAAKH,KAAOuP,EAAOtB,WAAanG,EAAQhJ,EAC3CG,EAAGkB,EAAKN,IAAM0P,EAAOrB,UAAYpG,EAAQ7I,EACzCF,MAAOoB,EAAKpB,MACZG,OAAQiB,EAAKjB,O,CAIjB,MAAMsR,GAAW,C,gBAlGjB,SAAyB/R,GACvB,IAAIyC,QACFA,EAAOL,SACPA,EAAQC,aACRA,EAAYF,SACZA,GACEnC,EACJ,MAAMgS,EAAwC,sBAAb5P,EAxCnC,SAAqCK,EAASwP,GAC5C,MAAMC,EAAeD,EAAME,IAAI1P,GAC/B,GAAIyP,EACF,OAAOA,EAET,IAAIpC,EAASM,GAAqB3N,GAASkD,QAAOyM,GAAMnH,EAAUmH,IAA2B,SAApBxH,EAAYwH,KACjFC,EAAsC,KAC1C,MAAMC,EAA0D,UAAzC9H,EAAmB/H,GAAS4O,SACnD,IAAIK,EAAcY,EAAiBzC,GAAcpN,GAAWA,EAG5D,KAAOwI,EAAUyG,KAAiBpF,EAAsBoF,IAAc,CACpE,MAAMa,EAAgB/H,EAAmBkH,GACnCc,EAA0B7G,EAAkB+F,GAC7Cc,GAAsD,UAA3BD,EAAclB,WAC5CgB,EAAsC,OAEVC,GAAkBE,IAA4BH,GAAuCG,GAAsD,WAA3BD,EAAclB,UAA2BgB,GAAuC,CAAC,WAAY,SAASvS,SAASuS,EAAoChB,WAAahG,EAAkBqG,KAAiBc,GAA2BrB,GAAyB1O,EAASiP,IAG5Y5B,EAASA,EAAOnK,QAAO8M,GAAYA,IAAaf,IAGhDW,EAAsCE,EAExCb,EAAc7B,GAAc6B,E,CAG9B,OADAO,EAAMS,IAAIjQ,EAASqN,GACZA,C,CAY6D6C,CAA4BlQ,EAASmQ,KAAKC,IAAM,GAAG3O,OAAO9B,GACxH0Q,EAAoB,IAAId,EAA0B3P,GAClD0Q,EAAwBD,EAAkB,GAC1CE,EAAeF,EAAkB/O,QAAO,CAACkP,EAASzC,KACtD,MAAM9O,EAAO6O,GAAkC9N,EAAS+N,EAAkBrO,GAK1E,OAJA8Q,EAAQ7R,IAAMoL,EAAI9K,EAAKN,IAAK6R,EAAQ7R,KACpC6R,EAAQ5R,MAAQkL,EAAI7K,EAAKL,MAAO4R,EAAQ5R,OACxC4R,EAAQ3R,OAASiL,EAAI7K,EAAKJ,OAAQ2R,EAAQ3R,QAC1C2R,EAAQ1R,KAAOiL,EAAI9K,EAAKH,KAAM0R,EAAQ1R,MAC/B0R,CAAO,GACb1C,GAAkC9N,EAASsQ,EAAuB5Q,IACrE,MAAO,CACL7B,MAAO0S,EAAa3R,MAAQ2R,EAAazR,KACzCd,OAAQuS,EAAa1R,OAAS0R,EAAa5R,IAC3Cf,EAAG2S,EAAazR,KAChBf,EAAGwS,EAAa5R,I,wDAtOpB,SAA+DpB,GAC7D,IAAI0B,KACFA,EAAIqB,aACJA,EAAYZ,SACZA,GACEnC,EACJ,MAAM6R,EAA0B9G,EAAchI,GACxCuM,EAAkBF,GAAmBrM,GAC3C,GAAIA,IAAiBuM,EACnB,OAAO5N,EAET,IAAIoP,EAAS,CACXtB,WAAY,EACZC,UAAW,GAEThB,EAAQ5B,EAAkB,GAC9B,MAAMxD,EAAUwD,EAAkB,GAClC,IAAIgF,IAA4BA,GAAwC,UAAb1P,MACvB,SAA9ByI,EAAY7H,IAA4BsI,EAAkBiE,MAC5DwB,EAASvB,GAAcxM,IAErBgI,EAAchI,IAAe,CAC/B,MAAM+O,EAAazD,GAAsBtL,GACzC0L,EAAQnB,EAASvK,GACjBsG,EAAQhJ,EAAIyR,EAAWzR,EAAI0C,EAAaiM,WACxC3F,EAAQ7I,EAAIsR,EAAWtR,EAAIuC,EAAamM,S,CAG5C,MAAO,CACL5O,MAAOoB,EAAKpB,MAAQmO,EAAMpO,EAC1BI,OAAQiB,EAAKjB,OAASgO,EAAMjO,EAC5BH,EAAGqB,EAAKrB,EAAIoO,EAAMpO,EAAIyQ,EAAOtB,WAAaf,EAAMpO,EAAIgJ,EAAQhJ,EAC5DG,EAAGkB,EAAKlB,EAAIiO,EAAMjO,EAAIsQ,EAAOrB,UAAYhB,EAAMjO,EAAI6I,EAAQ7I,E,YAqR7DyK,E,cA3EF,SAAuBxI,GACrB,OAAOqK,EAAiBrK,E,kBA4ExB+O,G,mBACApC,G,SACA9B,EACA3L,sBAAsB3B,GACpB,IAAIE,UACFA,EAASC,SACTA,EAAQgC,SACRA,GACEnC,EACJ,MAAMkT,EAAoBN,KAAK5P,iBAAmBwO,GAC5C2B,EAAkBP,KAAKQ,cAC7B,MAAO,CACLlT,UAAW0R,GAA8B1R,QAAiBgT,EAAkB/S,GAAWgC,GACvFhC,SAAU,CACRE,EAAG,EACHG,EAAG,WACO2S,EAAgBhT,I,EAIhCkT,eAAgB5Q,GAAW6Q,MAAMC,KAAK9Q,EAAQ4Q,kBAC9CnN,MAAOzD,GAAqD,QAA1C+H,EAAmB/H,GAASwF,WAwEhD,SAASuL,GAAWtT,EAAWC,EAAUsT,EAAQ3R,QAC/B,IAAZA,IACFA,EAAU,IAEZ,MAAM4R,eACJA,GAAiB,EAAIC,eACrBA,GAAiB,EAAIC,cACrBA,GAAgB,EAAIC,YACpBA,EAA8C,mBAAzBC,qBAAmCC,eACxDA,GAAiB,GACfjS,EACEkS,EAAc3G,EAAcnN,GAC5B+T,EAAYP,GAAkBC,EAAiB,IAAKK,EAAc5D,GAAqB4D,GAAe,MAAQ5D,GAAqBjQ,IAAa,GACtJ8T,EAAUC,SAAQzB,IAChBiB,GAAkBjB,EAAS0B,iBAAiB,SAAUV,EAAQ,CAC5DW,SAAS,IAEXT,GAAkBlB,EAAS0B,iBAAiB,SAAUV,EAAO,IAE/D,MAAMY,EAAYL,GAAeH,EAvFnC,SAAqBpR,EAAS6R,GAC5B,IACIC,EADAC,EAAK,KAET,MAAMC,EAAOrF,GAAmB3M,GAChC,SAASiS,IACPC,aAAaJ,GACbC,GAAMA,EAAGI,aACTJ,EAAK,I,CAkDP,OAhDA,SAASK,EAAQC,EAAMC,QACR,IAATD,IACFA,GAAO,QAES,IAAdC,IACFA,EAAY,GAEdL,IACA,MAAMnT,KACJA,EAAIH,IACJA,EAAGd,MACHA,EAAKG,OACLA,GACEgC,EAAQ+K,wBAIZ,GAHKsH,GACHR,KAEGhU,IAAUG,EACb,OAEF,MAAMuU,EAAWrI,EAAMvL,GACjB6T,EAAatI,EAAM8H,EAAK/D,aAAenP,EAAOjB,IAC9C4U,EAAcvI,EAAM8H,EAAK9D,cAAgBvP,EAAMX,IAC/C0U,EAAYxI,EAAMpL,GAExB,IAAI6T,GAAgB,EACpBZ,EAAK,IAAIV,sBAAqBuB,IAC5B,MAAMC,EAAQD,EAAQ,GAAGE,kBACzB,GAAID,IAAUP,EAAW,CACvB,IAAKK,EACH,OAAOP,IAEK,IAAVS,EACFf,EAAYiB,YAAW,KACrBX,GAAQ,EAAO,KAAK,GACnB,KAEHA,GAAQ,EAAOS,E,CAGnBF,GAAgB,CAAK,GACpB,C,YAjBiBJ,EAAW,OAASC,EAAa,OAASC,EAAc,OAASC,EAAY,K,UAmB/FJ,IAEFP,EAAGiB,QAAQhT,E,CAEboS,EAAQ,GACDH,C,CA8BwCgB,CAAY1B,EAAaP,GAAU,KAClF,IAQIkC,EARAC,EAAiB,KACjBhC,IACFgC,EAAiB,IAAIC,eAAepC,GAChCO,IAAgBD,GAClB6B,EAAeH,QAAQzB,GAEzB4B,EAAeH,QAAQtV,IAGzB,IAAI2V,EAAc/B,EAAiB1F,GAAsBnO,GAAa,KAatE,OAZI6T,GAGJ,SAASgC,IACP,MAAMC,EAAc3H,GAAsBnO,IACtC4V,GAAgBE,EAAY3V,IAAMyV,EAAYzV,GAAK2V,EAAYxV,IAAMsV,EAAYtV,GAAKwV,EAAY1V,QAAUwV,EAAYxV,OAAS0V,EAAYvV,SAAWqV,EAAYrV,QACtKgT,IAEFqC,EAAcE,EACdL,EAAUM,sBAAsBF,E,CARhCA,GAUFtC,IACO,KACLQ,EAAUC,SAAQzB,IAChBiB,GAAkBjB,EAASyD,oBAAoB,SAAUzC,GACzDE,GAAkBlB,EAASyD,oBAAoB,SAAUzC,EAAO,IAElEY,GAAaA,IACbuB,GAAkBA,EAAehB,aACjCgB,EAAiB,KACb7B,GACFoC,qBAAqBR,EAAQ,C,CAUnC,MAAMS,GAAkB,CAAClW,EAAWC,EAAU2B,KAI5C,MAAMmQ,EAAQ,IAAIoE,IACZC,EAAgB,C,SACpBvE,MACGjQ,GAECyU,EAAoB,IACrBD,EAActU,SACjB6Q,GAAIZ,GAEN,MAn7CwBtQ,OAAOzB,EAAWC,EAAUqW,KACpD,MAAMhX,UACJA,EAAY,SAAQ2C,SACpBA,EAAW,WAAUsU,WACrBA,EAAa,GAAEzU,SACfA,GACEwU,EACEE,EAAkBD,EAAW9Q,OAAOgR,SACpC1W,QAA+B,MAAlB+B,EAASkE,WAAgB,EAASlE,EAASkE,MAAM/F,IACpE,IAAI8B,QAAcD,EAAS4U,gBAAgB,C,UACzC1W,E,SACAC,E,SACAgC,KAEE9B,EACFA,EAACG,EACDA,GACET,EAA2BkC,EAAOzC,EAAWS,GAC7C4W,EAAoBrX,EACpB4F,EAAiB,GACjB0R,EAAa,EACjB,IAAK,IAAIC,EAAI,EAAGA,EAAIL,EAAgB/V,OAAQoW,IAAK,CAC/C,MAAM/R,KACJA,EAAIgS,GACJA,GACEN,EAAgBK,IAElB1W,EAAG4W,EACHzW,EAAG0W,EAAK1Q,KACRA,EAAIL,MACJA,SACQ6Q,EAAG,C,EACX3W,E,EACAG,EACA6G,iBAAkB7H,EAClBA,UAAWqX,E,SACX1U,E,eACAiD,E,MACAnD,E,SACAD,EACAE,SAAU,C,UACRhC,E,SACAC,KAGJE,EAAa,MAAT4W,EAAgBA,EAAQ5W,EAC5BG,EAAa,MAAT0W,EAAgBA,EAAQ1W,EAC5B4E,EAAiB,IACZA,EACHJ,CAACA,GAAO,IACHI,EAAeJ,MACfwB,IAGHL,GAAS2Q,GAAc,KACzBA,IACqB,iBAAV3Q,IACLA,EAAM3G,YACRqX,EAAoB1Q,EAAM3G,WAExB2G,EAAMlE,QACRA,GAAwB,IAAhBkE,EAAMlE,YAAuBD,EAAS4U,gBAAgB,C,UAC5D1W,E,SACAC,E,SACAgC,IACGgE,EAAMlE,SAEZ5B,EACCA,EAACG,EACDA,GACET,EAA2BkC,EAAO4U,EAAmB5W,KAE3D8W,GAAI,E,CAIR,MAAO,C,EACL1W,E,EACAG,EACAhB,UAAWqX,E,SACX1U,E,eACAiD,EACD,EAi2CM+R,CAAkBjX,EAAWC,EAAU,IACzCmW,EACHtU,SAAUuU,GACV,EASEa,GAAS,CAObC,qCAAqC,KARfC,WAAoC,yBAYtDC,GAWN5V,iBACE,GAAItC,EAAAmY,MAAMC,WACRL,GAAOC,sCAEN,kBAAkB5L,MAAK,EAAAiM,EAAAC,OAd5B,WACE,MAAMC,GAAS,EAAAF,EAAA3Q,KACf,OAAI6Q,GAAQC,SACDD,EAAOC,OAAOC,MAAK,EAACC,MAAEA,EAAKC,QAAEA,MAAyB,kBAAVD,GAAuC,aAAVA,IAAyBtK,OAAOuK,IAAY,QAEvHC,UAAUC,UAAUzY,MAAM,KAAKqY,MAAMK,IAC5C,MAAOC,EAASJ,GAAWG,EAAG1Y,MAAM,KACpC,MAAmB,WAAZ2Y,GAAwBC,SAASL,IAAY,GAAG,G,CAONM,IAAuB,CACxE,MAAMvV,aAAEA,SAAuBzD,EAAA,SACzBiZ,EAA0BxG,GAAS/O,gBACzC+O,GAAS/O,gBAAmBP,GAAY8V,EAAwB9V,EAASM,E,EAlB9CyV,GA2D/B,MAAMC,GAEN9W,MAAO+W,GAAW1E,YAAEA,EAAW2E,WAAEA,EAAUC,mBAAEA,EAAqB,WAAUpZ,UAAEA,EAASqZ,aAAEA,EAAYC,eAAEA,EAAcC,eAAEA,EAAcC,eAAEA,EAAcC,QAAEA,EAAOC,KAAEA,MAC9J,IAAKlF,IAAgB2E,EACnB,OAAO,WAEHpB,GACN,MAAMlX,EAAEA,EAACG,EAAEA,EAAGhB,UAAW2Z,EAAoBhX,SAAUkP,EAAQjM,eAAEA,SAAyBgR,GAAgBpC,EAAa2E,EAAY,CACjIxW,SAAUyW,EACVpZ,UAAyB,SAAdA,GAAsC,eAAdA,GAA4C,aAAdA,OAC7DkG,EACA0T,GAAsBT,EAAYnZ,GACtCiX,WAAY4C,GAAc,C,UACxB7Z,E,aACAqZ,E,eACAC,E,eACAC,E,eACAC,E,QACAC,E,KACAC,MAGJ,GAAID,GAAW7T,EAAekU,MAAO,CACnC,MAAQjZ,EAAAkZ,EAAG/Y,EAAAgZ,GAAMpU,EAAekU,MAC1BrV,EAAOkV,EAAmB1Z,MAAM,KAAK,GACrC8E,EAAiB,MAALgV,EAAY,OAAS,MACjCxN,EAAY0N,GAAoBxV,GAChCkC,EAAQ,CAAE5E,KAAM,GAAIH,IAAK,GAAIE,OAAQ,GAAID,MAAO,IAClD,mBAAoBqX,IACtBA,EAAUgB,eAA0B,SAATzV,GAA4B,UAATA,EAAmB,aAAe,YAElF0V,OAAOC,OAAOX,EAAQY,MAAO,IACxB1T,EACH5B,CAACA,GAAY,GAAgB,QAAbA,EAAsBgV,EAAIC,MAC1CvV,CAACA,GAAO,O,UACR8H,G,CAGJ,MAAMxC,EAAkBnE,EAAe0U,MAAMvQ,gBACvCwQ,EAAaxQ,EAAkB,SAAW,KAC1CyQ,EAAgBD,EAAa,OAAS,KAC5CpB,EAAWsB,aAAaC,GAAwBf,GAChD,MAAMgB,EAAY,aAAa7W,KAAKoJ,MAAMrM,QAAQiD,KAAKoJ,MAAMlM,QAC7DmZ,OAAOC,OAAOjB,EAAWkB,MAAO,C,WAC9BE,E,cACAC,E,SACA3I,EACAjQ,IAAK,IACLG,KAAM,IACNwK,UAAAoO,GACA,EAKED,GAAyB,iBAIzBE,GAA4B,IAC5BC,GAAsB,CAC1B,MACA,SACA,QACA,OACA,YACA,UACA,eACA,aACA,cACA,YACA,aACA,YAGIC,GAAc,CAClBC,UAAW,2BACXC,gBAAiB,oCAEnB,SAASnB,IAAc7Z,UAAEA,EAASqZ,aAAEA,EAAYC,eAAEA,EAAcC,eAAEA,EAAcC,eAAEA,EAAcC,QAAEA,EAAOC,KAAEA,IACzG,MAAMuB,EAAoB,OAv5BV,IAAZ3Y,IACFA,EAAU,IAEL,CACLkD,KAAM,Q,QACNlD,EACAH,SAASE,GACP,MAAMxB,EACJA,EAACG,EACDA,EAAChB,UACDA,GACEqC,GAEFnB,SAAU4G,GAAgB,EAC1BjC,UAAWkC,GAAiB,EAAKmT,QACjCA,EAAU,CACR1D,GAAIhX,IACF,IAAIK,EACFA,EAACG,EACDA,GACER,EACJ,MAAO,C,EACLK,E,EACAG,EACD,MAGFgF,GACDzE,EAASe,EAASD,GAChBf,EAAS,C,EACbT,E,EACAG,GAEIqF,QAAiBjE,EAAeC,EAAO2D,GACvC9E,EAAWb,EAAyBD,EAAQJ,IAC5C6F,EA5CM,MA4CmB3E,EA5Cb,IAAM,IA6CxB,IAAIia,EAAgB7Z,EAAOJ,GACvBka,EAAiB9Z,EAAOuE,GAC5B,GAAIiC,EAAe,CACjB,MACMuT,EAAuB,MAAbna,EAAmB,SAAW,QAG9Cia,EAAgBjX,EAFJiX,EAAgB9U,EAFC,MAAbnF,EAAmB,MAAQ,QAIfia,EADhBA,EAAgB9U,EAASgV,G,CAGvC,GAAItT,EAAgB,CAClB,MACMuT,EAAwB,MAAdzV,EAAoB,SAAW,QAG/CuV,EAAiBlX,EAFLkX,EAAiB/U,EAFC,MAAdR,EAAoB,MAAQ,QAIfuV,EADjBA,EAAiB/U,EAASiV,G,CAGxC,MAAMC,EAAgBL,EAAQ1D,GAAG,IAC5BnV,EACHnB,CAACA,GAAWia,EACZtV,CAACA,GAAYuV,IAEf,MAAO,IACFG,EACHvU,KAAM,CACJnG,EAAG0a,EAAc1a,EAAIA,EACrBG,EAAGua,EAAcva,EAAIA,G,IA01BO4I,KAx5BxB,IAAUtH,EAy5BtB,GAAa,SAAToX,EACF,MAAO,IACFuB,EACHtT,EAAK,CACHK,mBAAoBsR,GAAkB,CAAC,YAAa,MAAO,UAAW,eAAgB,SAAU,iBAItG,GAAa,YAATI,GAA+B,YAATA,EAAoB,CAC5C,MAAMzC,EAAa,IACdgE,EACH9Q,EAAO,CACLjJ,SAAoC,iBAAnBqY,EAA8BA,EAAiB,EAChE1T,UAAqC,iBAAnB2T,EAA8BA,EAAiB,KAcrE,MAXkB,SAAdxZ,GAAsC,eAAdA,GAA4C,aAAdA,EACxDiX,EAAWzO,KAAKjD,EAAc,CAAER,UAAyB,eAAd/E,EAA6B,QAAwB,aAAdA,EAA2B,MAAQ,QAE7GqZ,GACRpC,EAAWzO,KAAKb,EAAK2R,EAAiB,CAAEtR,mBAAoBsR,GAAmB,KAE7EG,GACFxC,EAAWzO,KA56CH,CAAAlG,IAAY,CACxBkD,KAAM,Q,QACNlD,EACAH,SAASE,GACP,MAAMxB,EACJA,EAACG,EACDA,EAAChB,UACDA,EAASyC,MACTA,EAAKD,SACLA,EAAQE,SACRA,GACEL,GAEEY,QACJA,EAAOtB,QACPA,EAAU,GACRJ,EAASe,EAASD,IAAU,GAChC,GAAe,MAAXY,EACF,MAAO,GAET,MAAMD,EAAgBtB,EAAyBC,GACzCL,EAAS,C,EACbT,E,EACAG,GAEIb,EAAOE,EAAyBL,GAChCmB,EAASjB,EAAkBC,GAC3Bqb,QAAwBhZ,EAASoR,cAAc3Q,GAC/CwY,EAAmB,MAATtb,EACVub,EAAUD,EAAU,MAAQ,OAC5BE,EAAUF,EAAU,SAAW,QAC/BG,EAAaH,EAAU,eAAiB,cACxCI,EAAUpZ,EAAM/B,UAAUS,GAAUsB,EAAM/B,UAAUP,GAAQmB,EAAOnB,GAAQsC,EAAM9B,SAASQ,GAC1F2a,EAAYxa,EAAOnB,GAAQsC,EAAM/B,UAAUP,GAC3C4b,QAAuD,MAA5BvZ,EAASgB,qBAA0B,EAAShB,EAASgB,gBAAgBP,IACtG,IAAI+Y,EAAaD,EAAoBA,EAAkBH,GAAc,EAGhEI,SAA6C,MAAtBxZ,EAASY,eAAoB,EAASZ,EAASY,UAAU2Y,MACnFC,EAAatZ,EAAS/B,SAASib,IAAenZ,EAAM9B,SAASQ,IAE/D,MAAM8a,EAAoBJ,EAAU,EAAIC,EAAY,EAI9CI,EAAyBF,EAAa,EAAIR,EAAgBra,GAAU,EAAI,EACxEgb,EAAatY,EAAMb,EAAc0Y,GAAUQ,GAC3CE,EAAavY,EAAMb,EAAc2Y,GAAUO,GAI3C/X,EAAUgY,EACVlY,EAAM+X,EAAaR,EAAgBra,GAAUib,EAC7CC,EAASL,EAAa,EAAIR,EAAgBra,GAAU,EAAI8a,EACxDK,EAASpY,EAAOC,EAASkY,EAAQpY,GAOjCsY,EAD6C,MAA3Bxc,EAAaC,IAAsBqc,GAAUC,GAAU7Z,EAAM/B,UAAUS,GAAU,GAAKkb,EAASlY,EAAUgY,EAAaC,GAAcZ,EAAgBra,GAAU,EAAI,EAChJkb,EAASlY,EAAUA,EAAUkY,EAASpY,EAAMoY,EAAS,EAC/F,MAAO,CACLlc,CAACA,GAAOmB,EAAOnB,GAAQoc,EACvBvV,KAAM,CACJ7G,CAACA,GAAOmc,EACRE,aAAcH,EAASC,EAASC,G,IA02ClBE,CAAM,CACpBxZ,QAASwW,KAGNxC,C,CAET,MAAO,E,CAET,SAASyF,GAAyBzW,EAAY2M,GAC5C,MAAM+J,EAAqB1W,EAAWE,QAAQnG,GAAc6a,GAAoBva,SAASN,KAOzF,OANI2c,EAAmBxb,SAAW8E,EAAW9E,QAC3Cyb,QAAQC,KAAK,GAAGjK,EAAGkK,sEAAsEjC,GACtF3T,KAAKlH,GAAc,IAAIA,OACvB+c,KAAK,MACLC,SAAU,C,GAAEpK,IAEV+J,C,CAET,SAAS/C,GAAsBT,EAAYnZ,GACzC,MAAMiG,EAAa,CAAC,OAAQ,SAI5B,MAHkC,SAA9B,EAAAgX,EAAAC,GAAc/D,IAChBlT,EAAWkX,UAENnd,EAAU6E,QAAO,YAAcoB,EAAW,IAAIpB,QAAO,aAAeoB,EAAW,G,CAqBxF9D,eAAeib,GAAWlE,EAAW5W,EAAS+a,GAAU,GACtD,IAAKnE,EAAUoE,KACb,OAEF,MAAMC,EAAmBF,EAG3B,SAAgCnE,GAC9B,IAAIsE,EAAYC,GAAkC9K,IAAIuG,GACtD,OAAIsE,IAGJA,GAAY,EAAAE,EAAAvW,GAAS8R,GAAoB2B,GAA2B,CAClE+C,SAAS,EACTC,QAAShD,KAEX6C,GAAkCvK,IAAIgG,EAAWsE,GAC1CA,E,CAb4BK,CAAuB3E,GAAaD,GACvE,OAAOsE,EAAiBrE,EAAW5W,E,CAcrC,MAAM2X,GAAsB,CAC1BrY,IAAK,GACLG,KAAM,iBACND,OAAQ,iBACRD,MAAO,iBAOHic,GAAa,IAAIC,QACjBN,GAAoC,IAAIM,QAQ9C,SAASC,GAAkB9E,EAAW1E,EAAa2E,GACjD,IAAKA,IAAe3E,EAClB,OAEFyJ,GAAqB/E,EAAW1E,EAAa2E,GAC7CgB,OAAOC,OAAOjB,EAAWkB,MAAO,CAC9BE,WAAY,SACZC,cAAe,OAEf3I,SAAUqH,EAAUE,mBACpBxX,IAAK,IACLG,KAAM,MAER,MAAMmc,EAAgBre,EAAAmY,MAAMC,UACxBjE,GACA,CAACmK,EAAQC,EAAaC,KACtBA,IACO,QAIXP,GAAW5K,IAAIgG,EAAWgF,EAAc1J,EAAa2E,GAAY,IAAMD,EAAUoF,e,CASnF,SAASL,GAAqB/E,EAAW1E,EAAa2E,GAC/CA,GAAe3E,IAGpBsJ,GAAWnL,IAAIuG,EAAf4E,KACAA,GAAWS,OAAOrF,GAClBuE,GAAkC9K,IAAIuG,IAAYsF,SAClDf,GAAkCc,OAAOrF,G,CAE3C,MAMMuF,GAAwB3a,KAAK4a,KAAK5a,KAAK6a,MANlB,K,sCC/zD3BC,EAAAC,QAAiBC,OAAoB,KAAOhf,EAAA,SAAAif,QAA6C,UAAWC,MAAK,IAAMlf,EAAc,U,sCCsB7H,IAAAmf,EACAC,E,iJArBA,IAAIC,EAAU,GAoBdF,EAlBA,SAAkBG,GAGhB,IAFA,IAAIC,EAAOlF,OAAOkF,KAAKD,GAEd7H,EAAI,EAAGA,EAAI8H,EAAKle,OAAQoW,IAC/B4H,EAAQE,EAAK9H,IAAM6H,EAAMC,EAAK9H,G,EAelC2H,EAXA,SAAiBI,GACf,IAAIC,EAAWJ,EAAQG,GAEvB,GAAgB,MAAZC,EACF,MAAM,IAAIC,MAAM,oCAAsCF,GAGxD,OAAOC,C,uHCdTzf,EAAA,SAEA,MAAM2f,EAAiC,IAAI1B,QAC3C,SAAS2B,EAAgBC,GACnBA,EAAMC,eAAiBxM,KAAKyM,oBAAsBF,EAAMG,SAAW1M,KAAK2M,eAC1E3M,KAAKkK,KAAOlK,KAAK4M,eAAiB5M,KAAK6M,gB,CAG3C,SAASC,EAAcP,GACjBA,EAAMC,eAAiBxM,KAAKyM,oBAAsBF,EAAMG,SAAW1M,KAAK2M,eAC1E3M,KAAKkK,KAAOlK,KAAK+M,SAAW/M,KAAKgN,U,CA8CrC,SAASC,EAA0BnH,GAEjC,GADAoH,EAA6BpH,GACzBA,EAAU6G,aAAc,CAC1B,MAAMQ,EAAyBb,EAAgBc,KAAKtH,GAC9CuH,EAAuBP,EAAcM,KAAKtH,GAChDuG,EAA+BvM,IAAIgG,EAAW,CAC5CA,EAAU6G,aACVQ,EACAE,IAEFvH,EAAU6G,aAAapL,iBAAiB,kBAAmB4L,GAC3DrH,EAAU6G,aAAapL,iBAAiB,gBAAiB8L,E,EAQ7D,SAASH,EAA6BpH,GACpC,IAAKuG,EAA+BiB,IAAIxH,GACtC,OAEF,MAAO6G,EAAc3a,EAAOC,GAAOoa,EAA+B9M,IAAIuG,GACtE6G,EAAarJ,oBAAoB,kBAAmBtR,GACpD2a,EAAarJ,oBAAoB,gBAAiBrR,GAClDoa,EAA+BlB,OAAOrF,E,+EClFxC,IAAArZ,EAAAC,EAAA,SAEA,MAAM6gB,EACG,4BADHA,EAES,oCAETC,EAAW,CACf9f,MAAO,GACPG,OAAQ,EACR4f,YAAa,GAcTC,EAAgB,EAAC5G,eAAEA,EAAc6G,IAAEA,EAAGC,IAAEA,MAC5C,MAAMlgB,MAAEA,EAAKG,OAAEA,EAAM4f,YAAEA,GAAgBD,EACjCK,EAAOngB,EAAQ,EACfO,EAAgC,aAAnB6Y,EACbgH,EACJ,SAAKpgB,MACAA,EAAQmgB,KAAQhgB,MAChBggB,KAAQhgB,KAAUggB,KAAQhgB,MAEjC,OAAQ,EAAApB,EAAAshB,GAAE,MAAO,CAAE,cAAe,OAAQC,MAAOT,EAAW1f,OAAQH,EAAOigB,IAAKA,EAAKC,IAAKA,EAAKK,QAAS,OAAOvgB,KAASA,GAAUO,EAA2B,EAAdwf,KAAoB/f,MAAOA,GAASO,EAAawf,EAAc,IAC5MA,EAAc,IAAM,EAAAhhB,EAAAshB,GAAE,OAAQ,CAAEC,MAAOT,EAAiBxZ,EAAG+Z,EAAQI,KAAM,OAAQ,eAAgBT,EAAc,KAC/G,EAAAhhB,EAAAshB,GAAE,OAAQ,CAAEha,EAAG+Z,EAAQK,OAAQ,SAAU,C,sHClC7C,IAAA1hB,EAAAC,EAAA,S,iEAOA,MAAM0hB,EACO,YAIPC,EAAoB,mBAE1B,SAASC,EAA6BC,GACpC,MAAMC,iBAAEA,GAAqBD,EAC7B,OAAqC,iBAArBC,GAAgC,EAAA3E,EAAA4E,GAAkBF,EAAS,CAAErC,GAAIsC,IAAsBA,IACrG,I,CAmNJ,MAEME,EAAU,IAlNhB,MAuGEC,gBAAgBvN,EAAamN,GAC3BvO,KAAK4O,yBACL5O,KAAK6O,mBAAmB/O,IAAIsB,EAAamN,GACzC,MAAMO,EAAa9O,KAAK+O,6BAA6B3N,GACjD0N,GACF9O,KAAKgP,mBAAmBF,GAEU,IAAhC9O,KAAK4O,wBACP5O,KAAKiP,c,CAGTC,kBAAkB9N,GAChB,MAAM0N,EAAa9O,KAAK+O,6BAA6B3N,GACjD0N,GACF9O,KAAKmP,qBAAqBL,GAExB9O,KAAK6O,mBAAmB1D,OAAO/J,IACjCpB,KAAK4O,yBAE6B,IAAhC5O,KAAK4O,wBACP5O,KAAKoP,iB,CAGTC,mBAAmBP,GACjBA,EAAWvN,iBAAiB,UAAWvB,KAAKsP,eAAgB,CAAEC,SAAS,IACvET,EAAWvN,iBAAiB,WAAYvB,KAAKwP,gBAAiB,CAAED,SAAS,G,CAE3EE,sBAAsBX,GACpBA,EAAWxL,oBAAoB,UAAWtD,KAAKsP,eAAgB,CAAEC,SAAS,IAC1ET,EAAWxL,oBAAoB,WAAYtD,KAAKwP,gBAAiB,CAAED,SAAS,G,CAE9EN,eACExS,SAAS8E,iBAAiB,UAAWvB,KAAK0P,eAAgB,CAAEH,SAAS,IACrE9S,SAAS8E,iBAAiB,cAAevB,KAAK2P,mBAAoB,CAAEJ,SAAS,IAC7E9S,SAAS8E,iBAAiB,cAAevB,KAAK4P,mBAAoB,CAAEL,SAAS,IAC7E9S,SAAS8E,iBAAiB,UAAWvB,KAAKsP,eAAgB,CAAEC,SAAS,IACrE9S,SAAS8E,iBAAiB,WAAYvB,KAAKwP,gBAAiB,CAAED,SAAS,G,CAEzEH,kBACE3S,SAAS6G,oBAAoB,UAAWtD,KAAK0P,eAAgB,CAAEH,SAAS,IACxE9S,SAAS6G,oBAAoB,cAAetD,KAAK2P,mBAAoB,CAAEJ,SAAS,IAChF9S,SAAS6G,oBAAoB,cAAetD,KAAK4P,mBAAoB,CAAEL,SAAS,IAChF9S,SAAS6G,oBAAoB,UAAWtD,KAAKsP,eAAgB,CAAEC,SAAS,IACxE9S,SAAS6G,oBAAoB,WAAYtD,KAAKwP,gBAAiB,CAAED,SAAS,G,CAE5EM,wBACElY,OAAOoK,aAAa/B,KAAK8P,kBACzB9P,KAAK8P,iBAAmB,I,CAE1BC,yBACEpY,OAAOoK,aAAa/B,KAAKgQ,mBACzBhQ,KAAKgQ,kBAAoB,I,CAE3BC,oBACEjQ,KAAK6P,wBACL7P,KAAK+P,wB,CAEPG,qBACE,MAAMC,cAAEA,GAAkBnQ,KACtBmQ,GAAejG,MACjBlK,KAAKoQ,cAAcD,GAAe,E,CAGtCE,qBAAqB9B,EAASrE,GAC5BlK,KAAKkQ,qBACDhG,GACFlK,KAAKiQ,oBAEPjQ,KAAKoQ,cAAc7B,EAASrE,E,CAE9BkG,cAAc7B,EAASrE,GACrBqE,EAAQrE,KAAOA,EACflK,KAAKmQ,cAAgBjG,EAAOqE,EAAU,I,CAExC+B,oBAAoB/D,EAAOrC,GACzB,MAAMqE,EAAUvO,KAAKuQ,aAAahE,EAAMiE,gBACnCjC,IAAWvO,KAAKyQ,yBAAyBlC,IAG9CvO,KAAKqQ,qBAAqB9B,EAASrE,E,CAErCuG,yBAAyBlC,GACvB,OAAOA,GAASmC,cAAgBnC,IAAYvO,KAAK2Q,c,CAEnD3B,mBAAmBF,GACjB,MAAM8B,2BAAEA,GAA+B5Q,KACjC6Q,GAAYD,EAA2BrR,IAAIuP,IAAe,GAAK,EACpD,IAAb+B,GACF7Q,KAAKqP,mBAAmBP,GAE1B8B,EAA2B9Q,IAAIgP,EAAY+B,E,CAE7C1B,qBAAqBL,GACnB,MAAM8B,2BAAEA,GAA+B5Q,KACjC6Q,EAAWD,EAA2BrR,IAAIuP,GAAc,EAC7C,IAAb+B,GACF7Q,KAAKyP,sBAAsBX,GAE7B8B,EAA2B9Q,IAAIgP,EAAY+B,E,CAE7C9B,6BAA6B3N,GAC3B,OAAOA,aAAuB9I,SAAU,EAAAuR,EAAA5V,GAAkBmN,GAAe,I,CA3M3E0P,cAME9Q,KAAK6O,mBAAqB,IAAIlE,QAC9B3K,KAAK4Q,2BAA6B,IAAIjG,QACtC3K,KAAK8P,iBAAmB,KACxB9P,KAAKgQ,kBAAoB,KACzBhQ,KAAK+Q,eAAiB,KACtB/Q,KAAK2Q,eAAiB,KACtB3Q,KAAKmQ,cAAgB,KACrBnQ,KAAK4O,uBAAyB,EAM9B5O,KAAKuQ,aAAgBC,IACnB,MAAM3B,mBAAEA,GAAuB7O,KACzBgR,EAAoBR,EAAatL,MAAM+L,GAAWpC,EAAmBvB,IAAI2D,KAC/E,OAAOpC,EAAmBtP,IAAIyR,EAAkB,EAElDhR,KAAK0P,eAAkBnD,IACrB,GAAkB,WAAdA,EAAMoB,MAAqBpB,EAAM2E,iBAAkB,CACrD,MAAMf,cAAEA,GAAkBnQ,KAC1B,GAAImQ,GAAejG,KAAM,CACvBlK,KAAKiQ,oBACLjQ,KAAKkQ,qBACL,MAAM1B,EAAmBF,EAA6B6B,GAClD3B,aAA4BlW,SAAWkW,EAAiB2C,SAAS5E,EAAMG,SACzEH,EAAM6E,gB,IAKdpR,KAAK2P,mBAAsBpD,IACzB,MAAMiE,EAAejE,EAAMiE,gBACrBL,cAAEA,GAAkBnQ,KAE1B,GAD8BmQ,GAAejG,MAAQsG,EAAatjB,SAASijB,GAGzE,YADAnQ,KAAKiQ,oBAGP,MAAM1B,EAAUvO,KAAKuQ,aAAaC,GAClCxQ,KAAK+Q,eAAiBxC,EAClBvO,KAAKyQ,yBAAyBlC,KAGlCvO,KAAK2Q,eAAiB,KAClBpC,EACFvO,KAAKqR,mBAAmB9C,GAEjB4B,GACPnQ,KAAKsR,sBAAqB,EAG9BtR,KAAK4P,mBAAsBrD,IACzB,KAAK,EAAA1C,EAAA0H,GAAuBhF,GAC1B,OAEF,MAAMoE,EAAiB3Q,KAAKuQ,aAAahE,EAAMiE,gBAC/CxQ,KAAK2Q,eAAiBA,EAClBA,GAAgBD,eAClB1Q,KAAKoQ,cAAcO,GAAgB,GACnC3Q,KAAKiQ,oB,EAGTjQ,KAAKsP,eAAkB/C,IACrBvM,KAAKsQ,oBAAoB/D,GAAO,EAAK,EAEvCvM,KAAKwP,gBAAmBjD,IACtBvM,KAAKsQ,oBAAoB/D,GAAO,EAAM,EAExCvM,KAAKqR,mBAAsB9C,IACzBvO,KAAK8P,iBAAmBnY,OAAOiL,YAAW,KACV,OAA1B5C,KAAK8P,mBAGT9P,KAAK+P,yBACL/P,KAAKkQ,qBACD3B,IAAYvO,KAAK+Q,gBAGrB/Q,KAAKoQ,cAAc7B,GAAS,GAAK,GAChCvO,KAAKmQ,cAAgB,EAjGA,IAiG0B,EAEpDnQ,KAAKsR,oBAAsB,KACzBtR,KAAKgQ,kBAAoBrY,OAAOiL,YAAW,KACV,OAA3B5C,KAAKgQ,mBAGThQ,KAAKkQ,oBAAoB,GAvGF,IAwGC,C,GAoH1BsB,GAAwB,EAAA/kB,EAAAglB,oBAAmB,cAAchlB,EAAA2L,YA+D7DsZ,8BACE1R,KAAKkL,YAAW,E,CAElByG,wBACE3R,KAAKkL,YAAW,E,CAElB0G,YAAYxjB,GACNA,GACF4R,KAAKkL,YAAW,E,CAGpB2G,4BACE7R,KAAKkL,YAAW,E,CAElB4G,mBACE9R,KAAKkL,YAAW,E,CAElB6G,0BACE/R,KAAKgS,uB,CAOPC,qBACE,EAAAC,EAAApI,GAA0B9J,MAC1BA,KAAKgS,sBAAsBhS,KAAKmS,U,CAElCC,mBACMpS,KAAKwO,mBAAqBxO,KAAKqS,2BACjCrS,KAAKgS,wBAEPhS,KAAKkL,YAAW,GAChBlL,KAAKmS,WAAY,C,CAEnBG,uBACEtS,KAAKuS,oBACL,EAAAC,EAAAre,GAAqB6L,KAAMA,KAAKqS,0BAA2BrS,KAAKR,KAChE,EAAA0S,EAAAne,GAA6BiM,K,CAY/BjR,iBAAiBkb,GAAU,GACzB,MAAMzK,GAAEA,EAAE6S,0BAAEA,EAAyBzlB,UAAEA,EAASoZ,mBAAEA,EAAkBG,eAAEA,EAAcC,eAAEA,EAAcC,QAAEA,GAAYrG,KAClH,OAAO,EAAAwS,EAAAC,GAAWzS,KAAM,CACtB+F,WAAYvG,EACZ4B,YAAaiR,E,mBACbrM,E,UACApZ,E,eACAuZ,E,eACAC,E,QACAC,EACAC,KAAM,WACL2D,E,CAOL2C,eACE5M,KAAK0S,yBAAyBC,M,CAEhC5F,SACE/M,KAAK4S,mBAAmBD,M,CAE1B9F,gBACE7M,KAAK6S,0BAA0BF,M,CAEjC3F,UACEhN,KAAK8S,oBAAoBH,M,CAO3BI,SACE,MAAMV,0BAAEA,EAAyBW,MAAEA,EAAK9I,KAAEA,EAAIpD,eAAEA,GAAmB9G,KAC7DiT,EAAYZ,GAA6BnI,EACzCgJ,GAAUD,EAChB,OAAQ,EAAAxmB,EAAAshB,GAAEthB,EAAA0mB,KAAM,CAAE,eAAe,EAAAtJ,EAAAuJ,GAAcF,GAAS,aAAcF,EAAO,YAAa,SAAU,0BAA2BE,EAAQhH,GAAIlM,KAAKqT,QAASC,KAAM,YAAa,EAAA7mB,EAAAshB,GAAE,MAAO,CAAEC,MAAO,CAC1L,CAACwE,EAAAe,EAAY5L,YAAY,EACzB,CAAC6K,EAAAe,EAAY3L,iBAAkBqL,GAGjCrF,IAAK5N,KAAKwT,kBAAmB,EAAA/mB,EAAAshB,GAAE0F,EAAAF,EAAe,CAAEzM,eAAgBA,EAEhE8G,IAAMvH,GAAarG,KAAKqG,QAAUA,KAAa,EAAA5Z,EAAAshB,GAAE,MAAO,CAAEC,MAAOI,IAAiB,EAAA3hB,EAAAshB,GAAE,OAAQ,Q,CAE5FvO,SAAO,OAAOQ,I,CACP0T,sBAAa,MAAO,CAC7BvN,eAAkB,CAAC,+BACnBC,eAAkB,CAAC,yBACnB8D,KAAQ,CAAC,eACTlE,mBAAsB,CAAC,6BACvBpZ,UAAa,CAAC,oBACd4hB,iBAAoB,CAAC,2B,CAEZvH,mBAAU,MA9KJ,6wG,CAIjB6J,cACE6C,QACA3T,KAAK4T,iBACL5T,KAAK6T,iBACL7T,KAAK6S,2BAA4B,EAAApmB,EAAAqnB,aAAY9T,KAAM,4BAA6B,GAChFA,KAAK8S,qBAAsB,EAAArmB,EAAAqnB,aAAY9T,KAAM,sBAAuB,GACpEA,KAAK0S,0BAA2B,EAAAjmB,EAAAqnB,aAAY9T,KAAM,2BAA4B,GAC9EA,KAAK4S,oBAAqB,EAAAnmB,EAAAqnB,aAAY9T,KAAM,qBAAsB,GAClEA,KAAK+T,KAAO,oBAAmB,EAAAC,EAAAjP,OAC/B/E,KAAKmS,WAAY,EACjBnS,KAAKyM,mBAAqB,UAC1BzM,KAAKwT,gBAAmBhU,IACtBQ,KAAK2M,aAAenN,GACpB,EAAA0S,EAAApI,GAA0B9J,KAAK,EAEjCA,KAAKgS,sBAAwB,CAACvI,GAAO,KACnCzJ,KAAKuS,mBACLvS,KAAKqS,0BAA4B/D,EAA6BtO,KAAKR,KACnE,EAAAgT,EAAA1I,GAAkB9J,KAAMA,KAAKqS,0BAA2BrS,KAAKR,IAC7D,MAAMA,GAAEA,EAAEgP,iBAAEA,EAAgB6D,0BAAEA,GAA8BrS,KACxDyJ,GAAQ+E,IAAqB6D,GAC/B7I,QAAQC,KAAK,GAAGjK,EAAGkK,kCAAkC8E,oBAAoC,C,GACvFhP,IAGJQ,KAAKiU,eAAe,EAEtBjU,KAAKqT,MAAQ,IACJrT,KAAKR,GAAG0M,IAAMlM,KAAK+T,KAE5B/T,KAAKiU,cAAgB,KACnB,MAAM5B,0BAAEA,GAA8BrS,KACtC,IAAKqS,EACH,OAEF,MAAMnG,EAAKlM,KAAKqT,QACZ,iBAAkBhB,GACpBA,EAA0BhL,aAAagH,EAAmBnC,GAE5DwC,EAAQC,gBAAgB0D,EAA2BrS,KAAKR,GAAG,EAE7DQ,KAAKuS,iBAAmB,KACtB,MAAMF,0BAAEA,GAA8BrS,KACjCqS,IAGD,oBAAqBA,GACvBA,EAA0B6B,gBAAgB7F,GAE5CK,EAAQQ,kBAAkBmD,GAA0B,EAEtDrS,KAAK0Q,cAAe,EACpB1Q,KAAKgT,WAAQlgB,EACbkN,KAAKmG,eAAiBqM,EAAApe,EACtB4L,KAAKoG,eAAiB,EACtBpG,KAAKkK,MAAO,EACZlK,KAAKgG,mBAAqB,WAC1BhG,KAAKpT,UAAY,OACjBoT,KAAKwO,sBAAmB1b,EACxBkN,KAAKqS,+BAA4Bvf,EACjCkN,KAAK8G,eAAiB,U,GA+GvB,CAAC,EAAG,kBAAmB,CACtB4J,aAAgB,CAAC,IAAK,kBACtBsC,MAAS,CAAC,GACV7M,eAAkB,CAAC,IAAK,mBACxBC,eAAkB,CAAC,IAAK,mBACxB8D,KAAQ,CAAC,KACTlE,mBAAsB,CAAC,IAAK,uBAC5BpZ,UAAa,CAAC,KACd4hB,iBAAoB,CAAC,EAAG,qBACxB6D,0BAA6B,CAAC,IAC9BvL,eAAkB,CAAC,IACnBoE,WAAc,CAAC,OAEnB,SAASiJ,IACP,GAA8B,oBAAnBC,eACT,OAEiB,CAAC,mBACT9S,SAAQoI,IAAa,GACzB,oBADiCA,EAE/B0K,eAAe7U,IAAImK,IACtB0K,eAAeC,OAAO3K,EAAS8H,E,IAKvC2C,G","sources":["node_modules/@esri/calcite-components/dist/components/floating-ui.js","node_modules/@parcel/runtime-js/lib/runtime-cd16c435cf02c5c8.js","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@esri/calcite-components/dist/components/openCloseComponent.js","node_modules/@esri/calcite-components/dist/components/FloatingArrow.js","node_modules/@esri/calcite-components/dist/components/tooltip.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.4.3\n */\nimport { Build } from '@stencil/core/internal/client/index.js';\nimport { c as getElementDir } from './dom.js';\nimport { g as getUserAgentString, a as getUserAgentData } from './browser.js';\nimport { d as debounce } from './debounce.js';\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition$1 = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\nconst min$1 = Math.min;\nconst max$1 = Math.max;\n\nfunction within(min$1$1, value, max$1$1) {\n  return max$1(min$1$1, min$1(value, max$1$1));\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min$1(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min$1(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min$1$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. This stops `shift()` from taking action, but can\n    // be worked around by calling it again after the `arrow()` if desired.\n    const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1$1 ? min$1$1 - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset + alignmentOffset\n      }\n    };\n  }\n});\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements = alignment !== undefined || allowedPlacements === allPlacements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[main], overflow[cross]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return node instanceof getWindow(node).ShadowRoot || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const safari = isSafari();\n  const css = getComputedStyle$1(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || !safari && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !safari && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction isSafari() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createEmptyCoords = v => ({\n  x: v,\n  y: v\n});\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createEmptyCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createEmptyCoords(0);\nfunction getVisualOffsets(element, isFixed, floatingOffsetParent) {\n  var _win$visualViewport, _win$visualViewport2;\n  if (isFixed === void 0) {\n    isFixed = true;\n  }\n  if (!isSafari()) {\n    return noOffsets;\n  }\n  const win = element ? getWindow(element) : window;\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== win) {\n    return noOffsets;\n  }\n  return {\n    x: ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0,\n    y: ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0\n  };\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createEmptyCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = getVisualOffsets(domElement, isFixedStrategy, offsetParent);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createEmptyCoords(1);\n  const offsets = createEmptyCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isSafari();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createEmptyCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createEmptyCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getScale,\n  async getElementRects(_ref) {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n      floating: {\n        x: 0,\n        y: 0,\n        ...(await getDimensionsFn(floating))\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    clearTimeout(timeoutId);\n    io && io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    let isFirstUpdate = true;\n    io = new IntersectionObserver(entries => {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (ratio === 0) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }, {\n      rootMargin,\n      threshold\n    });\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = true,\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(update);\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo && cleanupIo();\n    resizeObserver && resizeObserver.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\n/**\n * This module helps users provide custom configuration for component internals.\n *\n * @internal\n */\nconst configOverrides = globalThis[\"calciteComponentsConfig\"];\nconst config = {\n  /**\n   * We apply a custom fix to improve positioning for non-Chromium browsers.\n   * The fix comes at a performance cost, so provides users a way to opt-out if necessary.\n   *\n   * @internal\n   */\n  floatingUINonChromiumPositioningFix: true,\n  ...configOverrides\n};\n\nconst floatingUIBrowserCheck = patchFloatingUiForNonChromiumBrowsers();\nfunction isChrome109OrAbove() {\n  const uaData = getUserAgentData();\n  if (uaData?.brands) {\n    return !!uaData.brands.find(({ brand, version }) => (brand === \"Google Chrome\" || brand === \"Chromium\") && Number(version) >= 109);\n  }\n  return !!navigator.userAgent.split(\" \").find((ua) => {\n    const [browser, version] = ua.split(\"/\");\n    return browser === \"Chrome\" && parseInt(version) >= 109;\n  });\n}\nasync function patchFloatingUiForNonChromiumBrowsers() {\n  if (Build.isBrowser &&\n    config.floatingUINonChromiumPositioningFix &&\n    // ⚠️ browser-sniffing is not a best practice and should be avoided ⚠️\n    (/firefox|safari/i.test(getUserAgentString()) || isChrome109OrAbove())) {\n    const { offsetParent } = await import('./composed-offset-position.esm.js');\n    const originalGetOffsetParent = platform.getOffsetParent;\n    platform.getOffsetParent = (element) => originalGetOffsetParent(element, offsetParent);\n  }\n}\n/**\n * Positions the floating element relative to the reference element.\n *\n * **Note:** exported for testing purposes only\n *\n * @param root0\n * @param root0.referenceEl\n * @param root0.floatingEl\n * @param root0.overlayPositioning\n * @param root0.placement\n * @param root0.flipDisabled\n * @param root0.flipPlacements\n * @param root0.offsetDistance\n * @param root0.offsetSkidding\n * @param root0.arrowEl\n * @param root0.type\n * @param component\n * @param root0.referenceEl.referenceEl\n * @param root0.referenceEl.floatingEl\n * @param root0.referenceEl.overlayPositioning\n * @param root0.referenceEl.placement\n * @param root0.referenceEl.flipDisabled\n * @param root0.referenceEl.flipPlacements\n * @param root0.referenceEl.offsetDistance\n * @param root0.referenceEl.offsetSkidding\n * @param root0.referenceEl.arrowEl\n * @param root0.referenceEl.type\n * @param component.referenceEl\n * @param component.floatingEl\n * @param component.overlayPositioning\n * @param component.placement\n * @param component.flipDisabled\n * @param component.flipPlacements\n * @param component.offsetDistance\n * @param component.offsetSkidding\n * @param component.arrowEl\n * @param component.type\n */\nconst positionFloatingUI = \n/* we export arrow function to allow us to spy on it during testing */\nasync (component, { referenceEl, floatingEl, overlayPositioning = \"absolute\", placement, flipDisabled, flipPlacements, offsetDistance, offsetSkidding, arrowEl, type }) => {\n  if (!referenceEl || !floatingEl) {\n    return null;\n  }\n  await floatingUIBrowserCheck;\n  const { x, y, placement: effectivePlacement, strategy: position, middlewareData } = await computePosition(referenceEl, floatingEl, {\n    strategy: overlayPositioning,\n    placement: placement === \"auto\" || placement === \"auto-start\" || placement === \"auto-end\"\n      ? undefined\n      : getEffectivePlacement(floatingEl, placement),\n    middleware: getMiddleware({\n      placement,\n      flipDisabled,\n      flipPlacements,\n      offsetDistance,\n      offsetSkidding,\n      arrowEl,\n      type\n    })\n  });\n  if (arrowEl && middlewareData.arrow) {\n    const { x, y } = middlewareData.arrow;\n    const side = effectivePlacement.split(\"-\")[0];\n    const alignment = x != null ? \"left\" : \"top\";\n    const transform = ARROW_CSS_TRANSFORM[side];\n    const reset = { left: \"\", top: \"\", bottom: \"\", right: \"\" };\n    if (\"floatingLayout\" in component) {\n      component.floatingLayout = side === \"left\" || side === \"right\" ? \"horizontal\" : \"vertical\";\n    }\n    Object.assign(arrowEl.style, {\n      ...reset,\n      [alignment]: `${alignment == \"left\" ? x : y}px`,\n      [side]: \"100%\",\n      transform\n    });\n  }\n  const referenceHidden = middlewareData.hide?.referenceHidden;\n  const visibility = referenceHidden ? \"hidden\" : null;\n  const pointerEvents = visibility ? \"none\" : null;\n  floatingEl.setAttribute(placementDataAttribute, effectivePlacement);\n  const transform = `translate(${Math.round(x)}px,${Math.round(y)}px)`;\n  Object.assign(floatingEl.style, {\n    visibility,\n    pointerEvents,\n    position,\n    top: \"0\",\n    left: \"0\",\n    transform\n  });\n};\n/**\n * Exported for testing purposes only\n */\nconst placementDataAttribute = \"data-placement\";\n/**\n * Exported for testing purposes only\n */\nconst repositionDebounceTimeout = 100;\nconst effectivePlacements = [\n  \"top\",\n  \"bottom\",\n  \"right\",\n  \"left\",\n  \"top-start\",\n  \"top-end\",\n  \"bottom-start\",\n  \"bottom-end\",\n  \"right-start\",\n  \"right-end\",\n  \"left-start\",\n  \"left-end\"\n];\nconst defaultMenuPlacement = \"bottom-start\";\nconst FloatingCSS = {\n  animation: \"calcite-floating-ui-anim\",\n  animationActive: \"calcite-floating-ui-anim--active\"\n};\nfunction getMiddleware({ placement, flipDisabled, flipPlacements, offsetDistance, offsetSkidding, arrowEl, type }) {\n  const defaultMiddleware = [shift(), hide()];\n  if (type === \"menu\") {\n    return [\n      ...defaultMiddleware,\n      flip({\n        fallbackPlacements: flipPlacements || [\"top-start\", \"top\", \"top-end\", \"bottom-start\", \"bottom\", \"bottom-end\"]\n      })\n    ];\n  }\n  if (type === \"popover\" || type === \"tooltip\") {\n    const middleware = [\n      ...defaultMiddleware,\n      offset({\n        mainAxis: typeof offsetDistance === \"number\" ? offsetDistance : 0,\n        crossAxis: typeof offsetSkidding === \"number\" ? offsetSkidding : 0\n      })\n    ];\n    if (placement === \"auto\" || placement === \"auto-start\" || placement === \"auto-end\") {\n      middleware.push(autoPlacement({ alignment: placement === \"auto-start\" ? \"start\" : placement === \"auto-end\" ? \"end\" : null }));\n    }\n    else if (!flipDisabled) {\n      middleware.push(flip(flipPlacements ? { fallbackPlacements: flipPlacements } : {}));\n    }\n    if (arrowEl) {\n      middleware.push(arrow({\n        element: arrowEl\n      }));\n    }\n    return middleware;\n  }\n  return [];\n}\nfunction filterComputedPlacements(placements, el) {\n  const filteredPlacements = placements.filter((placement) => effectivePlacements.includes(placement));\n  if (filteredPlacements.length !== placements.length) {\n    console.warn(`${el.tagName}: Invalid value found in: flipPlacements. Try any of these: ${effectivePlacements\n      .map((placement) => `\"${placement}\"`)\n      .join(\", \")\n      .trim()}`, { el });\n  }\n  return filteredPlacements;\n}\nfunction getEffectivePlacement(floatingEl, placement) {\n  const placements = [\"left\", \"right\"];\n  if (getElementDir(floatingEl) === \"rtl\") {\n    placements.reverse();\n  }\n  return placement.replace(/leading/gi, placements[0]).replace(/trailing/gi, placements[1]);\n}\n/**\n * Convenience function to manage `reposition` calls for FloatingUIComponents that use `positionFloatingUI.\n *\n * Note: this is not needed for components that use `calcite-popover`.\n *\n * @param component\n * @param options\n * @param options.referenceEl\n * @param options.floatingEl\n * @param options.overlayPositioning\n * @param options.placement\n * @param options.flipDisabled\n * @param options.flipPlacements\n * @param options.offsetDistance\n * @param options.offsetSkidding\n * @param options.arrowEl\n * @param options.type\n * @param delayed\n */\nasync function reposition(component, options, delayed = false) {\n  if (!component.open) {\n    return;\n  }\n  const positionFunction = delayed ? getDebouncedReposition(component) : positionFloatingUI;\n  return positionFunction(component, options);\n}\nfunction getDebouncedReposition(component) {\n  let debounced = componentToDebouncedRepositionMap.get(component);\n  if (debounced) {\n    return debounced;\n  }\n  debounced = debounce(positionFloatingUI, repositionDebounceTimeout, {\n    leading: true,\n    maxWait: repositionDebounceTimeout\n  });\n  componentToDebouncedRepositionMap.set(component, debounced);\n  return debounced;\n}\nconst ARROW_CSS_TRANSFORM = {\n  top: \"\",\n  left: \"rotate(-90deg)\",\n  bottom: \"rotate(180deg)\",\n  right: \"rotate(90deg)\"\n};\n/**\n * Exported for testing purposes only\n *\n * @internal\n */\nconst cleanupMap = new WeakMap();\nconst componentToDebouncedRepositionMap = new WeakMap();\n/**\n * Helper to set up floating element interactions on connectedCallback.\n *\n * @param component\n * @param referenceEl\n * @param floatingEl\n */\nfunction connectFloatingUI(component, referenceEl, floatingEl) {\n  if (!floatingEl || !referenceEl) {\n    return;\n  }\n  disconnectFloatingUI(component, referenceEl, floatingEl);\n  Object.assign(floatingEl.style, {\n    visibility: \"hidden\",\n    pointerEvents: \"none\",\n    // initial positioning based on https://floating-ui.com/docs/computePosition#initial-layout\n    position: component.overlayPositioning,\n    top: \"0\",\n    left: \"0\"\n  });\n  const runAutoUpdate = Build.isBrowser\n    ? autoUpdate\n    : (_refEl, _floatingEl, updateCallback) => {\n      updateCallback();\n      return () => {\n        /* noop */\n      };\n    };\n  cleanupMap.set(component, runAutoUpdate(referenceEl, floatingEl, () => component.reposition()));\n}\n/**\n * Helper to tear down floating element interactions on disconnectedCallback.\n *\n * @param component\n * @param referenceEl\n * @param floatingEl\n */\nfunction disconnectFloatingUI(component, referenceEl, floatingEl) {\n  if (!floatingEl || !referenceEl) {\n    return;\n  }\n  cleanupMap.get(component)?.();\n  cleanupMap.delete(component);\n  componentToDebouncedRepositionMap.get(component)?.cancel();\n  componentToDebouncedRepositionMap.delete(component);\n}\nconst visiblePointerSize = 4;\n/**\n * Default offset the position of the floating element away from the reference element.\n *\n * @default 6\n */\nconst defaultOffsetDistance = Math.ceil(Math.hypot(visiblePointerSize, visiblePointerSize));\n\nexport { FloatingCSS as F, disconnectFloatingUI as a, defaultOffsetDistance as b, connectFloatingUI as c, defaultMenuPlacement as d, filterComputedPlacements as f, reposition as r };\n","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"3SfBS\"))).then(() => parcelRequire('8JMjJ'));","\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.4.3\n */\nimport { readTask } from '@stencil/core/internal/client/index.js';\n\nconst componentToTransitionListeners = new WeakMap();\nfunction transitionStart(event) {\n  if (event.propertyName === this.openTransitionProp && event.target === this.transitionEl) {\n    this.open ? this.onBeforeOpen() : this.onBeforeClose();\n  }\n}\nfunction transitionEnd(event) {\n  if (event.propertyName === this.openTransitionProp && event.target === this.transitionEl) {\n    this.open ? this.onOpen() : this.onClose();\n  }\n}\n/**\n * Helper to determine globally set transition duration on the given openTransitionProp, which is imported and set in the @Watch(\"open\").\n * Used to emit (before)open/close events both for when the opacity transition is present and when there is none (transition-duration is set to 0).\n *\n * @param component\n * @param nonOpenCloseComponent\n */\nfunction onToggleOpenCloseComponent(component, nonOpenCloseComponent = false) {\n  readTask(() => {\n    if (component.transitionEl) {\n      const allTransitionPropsArray = getComputedStyle(component.transitionEl).transition.split(\" \");\n      const openTransitionPropIndex = allTransitionPropsArray.findIndex((item) => item === component.openTransitionProp);\n      const transitionDuration = allTransitionPropsArray[openTransitionPropIndex + 1];\n      if (transitionDuration === \"0s\") {\n        (nonOpenCloseComponent ? component[component.transitionProp] : component.open)\n          ? component.onBeforeOpen()\n          : component.onBeforeClose();\n        (nonOpenCloseComponent ? component[component.transitionProp] : component.open)\n          ? component.onOpen()\n          : component.onClose();\n      }\n      else {\n        component.transitionEl.addEventListener(\"transitionstart\", () => {\n          (nonOpenCloseComponent ? component[component.transitionProp] : component.open)\n            ? component.onBeforeOpen()\n            : component.onBeforeClose();\n        }, { once: true });\n        component.transitionEl.addEventListener(\"transitionend\", () => {\n          (nonOpenCloseComponent ? component[component.transitionProp] : component.open)\n            ? component.onOpen()\n            : component.onClose();\n        }, { once: true });\n      }\n    }\n  });\n}\n/**\n * Helper to keep track of transition listeners on setTransitionEl and connectedCallback on OpenCloseComponent components.\n *\n * For component which do not have open prop, use `onToggleOpenCloseComponent` implementation.\n *\n * @param component\n */\nfunction connectOpenCloseComponent(component) {\n  disconnectOpenCloseComponent(component);\n  if (component.transitionEl) {\n    const boundOnTransitionStart = transitionStart.bind(component);\n    const boundOnTransitionEnd = transitionEnd.bind(component);\n    componentToTransitionListeners.set(component, [\n      component.transitionEl,\n      boundOnTransitionStart,\n      boundOnTransitionEnd\n    ]);\n    component.transitionEl.addEventListener(\"transitionstart\", boundOnTransitionStart);\n    component.transitionEl.addEventListener(\"transitionend\", boundOnTransitionEnd);\n  }\n}\n/**\n * Helper to tear down transition listeners on disconnectedCallback on OpenCloseComponent components.\n *\n * @param component\n */\nfunction disconnectOpenCloseComponent(component) {\n  if (!componentToTransitionListeners.has(component)) {\n    return;\n  }\n  const [transitionEl, start, end] = componentToTransitionListeners.get(component);\n  transitionEl.removeEventListener(\"transitionstart\", start);\n  transitionEl.removeEventListener(\"transitionend\", end);\n  componentToTransitionListeners.delete(component);\n}\n\nexport { connectOpenCloseComponent as c, disconnectOpenCloseComponent as d, onToggleOpenCloseComponent as o };\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.4.3\n */\nimport { h } from '@stencil/core/internal/client/index.js';\n\nconst CSS = {\n  arrow: \"calcite-floating-ui-arrow\",\n  arrowStroke: \"calcite-floating-ui-arrow__stroke\"\n};\nconst DEFAULTS = {\n  width: 12,\n  height: 6,\n  strokeWidth: 1\n};\n/**\n * Renders a SVG element to be used as a floating-ui arrow.\n *\n * This functional component should be rendered inside a `FloatingUIComponent` when it needs an arrow element.\n *\n * @param floatingLayout.floatingLayout\n * @param floatingLayout – The effective floating layout to render the arrow vertically or horizontally. Possible values: `vertical` or `horizontal`.\n *\n * See [floating-ui](https://github.com/Esri/calcite-components/blob/master/src/utils/floating-ui.ts)\n * @param floatingLayout.key\n * @param floatingLayout.ref\n */\nconst FloatingArrow = ({ floatingLayout, key, ref }) => {\n  const { width, height, strokeWidth } = DEFAULTS;\n  const svgX = width / 2;\n  const isVertical = floatingLayout === \"vertical\";\n  const dValue = \"M0,0\" +\n    ` H${width}` +\n    ` L${width - svgX},${height}` +\n    ` Q${svgX},${height} ${svgX},${height}` +\n    \" Z\";\n  return (h(\"svg\", { \"aria-hidden\": \"true\", class: CSS.arrow, height: width, key: key, ref: ref, viewBox: `0 0 ${width} ${width + (!isVertical ? strokeWidth : 0)}`, width: width + (isVertical ? strokeWidth : 0) },\n    strokeWidth > 0 && (h(\"path\", { class: CSS.arrowStroke, d: dValue, fill: \"none\", \"stroke-width\": strokeWidth + 1 })),\n    h(\"path\", { d: dValue, stroke: \"none\" })));\n};\n\nexport { FloatingArrow as F };\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.4.3\n */\nimport { proxyCustomElement, HTMLElement, createEvent, h, Host } from '@stencil/core/internal/client/index.js';\nimport { u as queryElementRoots, j as isPrimaryPointerButton, v as getShadowRootNode, t as toAriaBoolean } from './dom.js';\nimport { c as connectFloatingUI, b as defaultOffsetDistance, a as disconnectFloatingUI, r as reposition, F as FloatingCSS } from './floating-ui.js';\nimport { g as guid } from './guid.js';\nimport { c as connectOpenCloseComponent, d as disconnectOpenCloseComponent } from './openCloseComponent.js';\nimport { F as FloatingArrow } from './FloatingArrow.js';\n\nconst CSS = {\n  container: \"container\"\n};\nconst TOOLTIP_OPEN_DELAY_MS = 300;\nconst TOOLTIP_CLOSE_DELAY_MS = 500;\nconst ARIA_DESCRIBED_BY = \"aria-describedby\";\n\nfunction getEffectiveReferenceElement(tooltip) {\n  const { referenceElement } = tooltip;\n  return ((typeof referenceElement === \"string\" ? queryElementRoots(tooltip, { id: referenceElement }) : referenceElement) ||\n    null);\n}\n\nclass TooltipManager {\n  constructor() {\n    // --------------------------------------------------------------------------\n    //\n    //  Private Properties\n    //\n    // --------------------------------------------------------------------------\n    this.registeredElements = new WeakMap();\n    this.registeredShadowRootCounts = new WeakMap();\n    this.hoverOpenTimeout = null;\n    this.hoverCloseTimeout = null;\n    this.hoveredTooltip = null;\n    this.clickedTooltip = null;\n    this.activeTooltip = null;\n    this.registeredElementCount = 0;\n    // --------------------------------------------------------------------------\n    //\n    //  Private Methods\n    //\n    // --------------------------------------------------------------------------\n    this.queryTooltip = (composedPath) => {\n      const { registeredElements } = this;\n      const registeredElement = composedPath.find((pathEl) => registeredElements.has(pathEl));\n      return registeredElements.get(registeredElement);\n    };\n    this.keyDownHandler = (event) => {\n      if (event.key === \"Escape\" && !event.defaultPrevented) {\n        const { activeTooltip } = this;\n        if (activeTooltip?.open) {\n          this.clearHoverTimeout();\n          this.closeActiveTooltip();\n          const referenceElement = getEffectiveReferenceElement(activeTooltip);\n          if (referenceElement instanceof Element && referenceElement.contains(event.target)) {\n            event.preventDefault();\n          }\n        }\n      }\n    };\n    this.pointerMoveHandler = (event) => {\n      const composedPath = event.composedPath();\n      const { activeTooltip } = this;\n      const hoveringActiveTooltip = activeTooltip?.open && composedPath.includes(activeTooltip);\n      if (hoveringActiveTooltip) {\n        this.clearHoverTimeout();\n        return;\n      }\n      const tooltip = this.queryTooltip(composedPath);\n      this.hoveredTooltip = tooltip;\n      if (this.isClosableClickedTooltip(tooltip)) {\n        return;\n      }\n      this.clickedTooltip = null;\n      if (tooltip) {\n        this.openHoveredTooltip(tooltip);\n      }\n      else if (activeTooltip) {\n        this.closeHoveredTooltip();\n      }\n    };\n    this.pointerDownHandler = (event) => {\n      if (!isPrimaryPointerButton(event)) {\n        return;\n      }\n      const clickedTooltip = this.queryTooltip(event.composedPath());\n      this.clickedTooltip = clickedTooltip;\n      if (clickedTooltip?.closeOnClick) {\n        this.toggleTooltip(clickedTooltip, false);\n        this.clearHoverTimeout();\n      }\n    };\n    this.focusInHandler = (event) => {\n      this.queryFocusedTooltip(event, true);\n    };\n    this.focusOutHandler = (event) => {\n      this.queryFocusedTooltip(event, false);\n    };\n    this.openHoveredTooltip = (tooltip) => {\n      this.hoverOpenTimeout = window.setTimeout(() => {\n        if (this.hoverOpenTimeout === null) {\n          return;\n        }\n        this.clearHoverCloseTimeout();\n        this.closeActiveTooltip();\n        if (tooltip !== this.hoveredTooltip) {\n          return;\n        }\n        this.toggleTooltip(tooltip, true);\n      }, this.activeTooltip ? 0 : TOOLTIP_OPEN_DELAY_MS);\n    };\n    this.closeHoveredTooltip = () => {\n      this.hoverCloseTimeout = window.setTimeout(() => {\n        if (this.hoverCloseTimeout === null) {\n          return;\n        }\n        this.closeActiveTooltip();\n      }, TOOLTIP_CLOSE_DELAY_MS);\n    };\n  }\n  // --------------------------------------------------------------------------\n  //\n  //  Public Methods\n  //\n  // --------------------------------------------------------------------------\n  registerElement(referenceEl, tooltip) {\n    this.registeredElementCount++;\n    this.registeredElements.set(referenceEl, tooltip);\n    const shadowRoot = this.getReferenceElShadowRootNode(referenceEl);\n    if (shadowRoot) {\n      this.registerShadowRoot(shadowRoot);\n    }\n    if (this.registeredElementCount === 1) {\n      this.addListeners();\n    }\n  }\n  unregisterElement(referenceEl) {\n    const shadowRoot = this.getReferenceElShadowRootNode(referenceEl);\n    if (shadowRoot) {\n      this.unregisterShadowRoot(shadowRoot);\n    }\n    if (this.registeredElements.delete(referenceEl)) {\n      this.registeredElementCount--;\n    }\n    if (this.registeredElementCount === 0) {\n      this.removeListeners();\n    }\n  }\n  addShadowListeners(shadowRoot) {\n    shadowRoot.addEventListener(\"focusin\", this.focusInHandler, { capture: true });\n    shadowRoot.addEventListener(\"focusout\", this.focusOutHandler, { capture: true });\n  }\n  removeShadowListeners(shadowRoot) {\n    shadowRoot.removeEventListener(\"focusin\", this.focusInHandler, { capture: true });\n    shadowRoot.removeEventListener(\"focusout\", this.focusOutHandler, { capture: true });\n  }\n  addListeners() {\n    document.addEventListener(\"keydown\", this.keyDownHandler, { capture: true });\n    document.addEventListener(\"pointermove\", this.pointerMoveHandler, { capture: true });\n    document.addEventListener(\"pointerdown\", this.pointerDownHandler, { capture: true });\n    document.addEventListener(\"focusin\", this.focusInHandler, { capture: true });\n    document.addEventListener(\"focusout\", this.focusOutHandler, { capture: true });\n  }\n  removeListeners() {\n    document.removeEventListener(\"keydown\", this.keyDownHandler, { capture: true });\n    document.removeEventListener(\"pointermove\", this.pointerMoveHandler, { capture: true });\n    document.removeEventListener(\"pointerdown\", this.pointerDownHandler, { capture: true });\n    document.removeEventListener(\"focusin\", this.focusInHandler, { capture: true });\n    document.removeEventListener(\"focusout\", this.focusOutHandler, { capture: true });\n  }\n  clearHoverOpenTimeout() {\n    window.clearTimeout(this.hoverOpenTimeout);\n    this.hoverOpenTimeout = null;\n  }\n  clearHoverCloseTimeout() {\n    window.clearTimeout(this.hoverCloseTimeout);\n    this.hoverCloseTimeout = null;\n  }\n  clearHoverTimeout() {\n    this.clearHoverOpenTimeout();\n    this.clearHoverCloseTimeout();\n  }\n  closeActiveTooltip() {\n    const { activeTooltip } = this;\n    if (activeTooltip?.open) {\n      this.toggleTooltip(activeTooltip, false);\n    }\n  }\n  toggleFocusedTooltip(tooltip, open) {\n    this.closeActiveTooltip();\n    if (open) {\n      this.clearHoverTimeout();\n    }\n    this.toggleTooltip(tooltip, open);\n  }\n  toggleTooltip(tooltip, open) {\n    tooltip.open = open;\n    this.activeTooltip = open ? tooltip : null;\n  }\n  queryFocusedTooltip(event, open) {\n    const tooltip = this.queryTooltip(event.composedPath());\n    if (!tooltip || this.isClosableClickedTooltip(tooltip)) {\n      return;\n    }\n    this.toggleFocusedTooltip(tooltip, open);\n  }\n  isClosableClickedTooltip(tooltip) {\n    return tooltip?.closeOnClick && tooltip === this.clickedTooltip;\n  }\n  registerShadowRoot(shadowRoot) {\n    const { registeredShadowRootCounts } = this;\n    const newCount = (registeredShadowRootCounts.get(shadowRoot) ?? 0) + 1;\n    if (newCount === 1) {\n      this.addShadowListeners(shadowRoot);\n    }\n    registeredShadowRootCounts.set(shadowRoot, newCount);\n  }\n  unregisterShadowRoot(shadowRoot) {\n    const { registeredShadowRootCounts } = this;\n    const newCount = registeredShadowRootCounts.get(shadowRoot) - 1;\n    if (newCount === 0) {\n      this.removeShadowListeners(shadowRoot);\n    }\n    registeredShadowRootCounts.set(shadowRoot, newCount);\n  }\n  getReferenceElShadowRootNode(referenceEl) {\n    return referenceEl instanceof Element ? getShadowRootNode(referenceEl) : null;\n  }\n}\n\nconst tooltipCss = \"@keyframes in{0%{opacity:0}100%{opacity:1}}@keyframes in-down{0%{opacity:0;transform:translate3D(0, -5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-up{0%{opacity:0;transform:translate3D(0, 5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-right{0%{opacity:0;transform:translate3D(-5px, 0, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-left{0%{opacity:0;transform:translate3D(5px, 0, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-scale{0%{opacity:0;transform:scale3D(0.95, 0.95, 1)}100%{opacity:1;transform:scale3D(1, 1, 1)}}:root{--calcite-animation-timing:calc(150ms * var(--calcite-internal-duration-factor));--calcite-internal-duration-factor:var(--calcite-duration-factor, 1);--calcite-internal-animation-timing-fast:calc(100ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-medium:calc(200ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-slow:calc(300ms * var(--calcite-internal-duration-factor))}.calcite-animate{opacity:0;animation-fill-mode:both;animation-duration:var(--calcite-animation-timing)}.calcite-animate__in{animation-name:in}.calcite-animate__in-down{animation-name:in-down}.calcite-animate__in-up{animation-name:in-up}.calcite-animate__in-right{animation-name:in-right}.calcite-animate__in-left{animation-name:in-left}.calcite-animate__in-scale{animation-name:in-scale}@media (prefers-reduced-motion: reduce){:root{--calcite-internal-duration-factor:0.01}}:root{--calcite-floating-ui-transition:var(--calcite-animation-timing);--calcite-floating-ui-z-index:var(--calcite-app-z-index-dropdown)}:host([hidden]){display:none}:host{--calcite-floating-ui-z-index:var(--calcite-tooltip-z-index, 901);display:block;position:absolute;z-index:var(--calcite-floating-ui-z-index)}.calcite-floating-ui-anim{position:relative;transition:var(--calcite-floating-ui-transition);transition-property:transform, visibility, opacity;opacity:0;box-shadow:0 0 16px 0 rgba(0, 0, 0, 0.16);z-index:var(--calcite-app-z-index);border-radius:0.25rem}:host([data-placement^=bottom]) .calcite-floating-ui-anim{transform:translateY(-5px)}:host([data-placement^=top]) .calcite-floating-ui-anim{transform:translateY(5px)}:host([data-placement^=left]) .calcite-floating-ui-anim{transform:translateX(5px)}:host([data-placement^=right]) .calcite-floating-ui-anim{transform:translateX(-5px)}:host([data-placement]) .calcite-floating-ui-anim--active{opacity:1;transform:translate(0)}:host([calcite-hydrated-hidden]){visibility:hidden !important;pointer-events:none}.calcite-floating-ui-arrow{pointer-events:none;position:absolute;z-index:calc(var(--calcite-app-z-index) * -1);fill:var(--calcite-ui-foreground-1)}.calcite-floating-ui-arrow__stroke{stroke:var(--calcite-ui-border-3)}.container{position:relative;overflow:hidden;border-radius:0.25rem;padding-block:0.75rem;padding-inline:1rem;font-size:var(--calcite-font-size--2);line-height:1.375;font-weight:var(--calcite-font-weight-medium);color:var(--calcite-ui-text-1);max-inline-size:20rem;max-block-size:20rem;text-align:start}.calcite-floating-ui-anim{border-radius:0.25rem;border-width:1px;border-style:solid;border-color:var(--calcite-ui-border-3);background-color:var(--calcite-ui-foreground-1)}.arrow::before{outline:1px solid var(--calcite-ui-border-3)}\";\n\nconst manager = new TooltipManager();\nconst Tooltip = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.calciteTooltipBeforeClose = createEvent(this, \"calciteTooltipBeforeClose\", 6);\n    this.calciteTooltipClose = createEvent(this, \"calciteTooltipClose\", 6);\n    this.calciteTooltipBeforeOpen = createEvent(this, \"calciteTooltipBeforeOpen\", 6);\n    this.calciteTooltipOpen = createEvent(this, \"calciteTooltipOpen\", 6);\n    this.guid = `calcite-tooltip-${guid()}`;\n    this.hasLoaded = false;\n    this.openTransitionProp = \"opacity\";\n    this.setTransitionEl = (el) => {\n      this.transitionEl = el;\n      connectOpenCloseComponent(this);\n    };\n    this.setUpReferenceElement = (warn = true) => {\n      this.removeReferences();\n      this.effectiveReferenceElement = getEffectiveReferenceElement(this.el);\n      connectFloatingUI(this, this.effectiveReferenceElement, this.el);\n      const { el, referenceElement, effectiveReferenceElement } = this;\n      if (warn && referenceElement && !effectiveReferenceElement) {\n        console.warn(`${el.tagName}: reference-element id \"${referenceElement}\" was not found.`, {\n          el\n        });\n      }\n      this.addReferences();\n    };\n    this.getId = () => {\n      return this.el.id || this.guid;\n    };\n    this.addReferences = () => {\n      const { effectiveReferenceElement } = this;\n      if (!effectiveReferenceElement) {\n        return;\n      }\n      const id = this.getId();\n      if (\"setAttribute\" in effectiveReferenceElement) {\n        effectiveReferenceElement.setAttribute(ARIA_DESCRIBED_BY, id);\n      }\n      manager.registerElement(effectiveReferenceElement, this.el);\n    };\n    this.removeReferences = () => {\n      const { effectiveReferenceElement } = this;\n      if (!effectiveReferenceElement) {\n        return;\n      }\n      if (\"removeAttribute\" in effectiveReferenceElement) {\n        effectiveReferenceElement.removeAttribute(ARIA_DESCRIBED_BY);\n      }\n      manager.unregisterElement(effectiveReferenceElement);\n    };\n    this.closeOnClick = false;\n    this.label = undefined;\n    this.offsetDistance = defaultOffsetDistance;\n    this.offsetSkidding = 0;\n    this.open = false;\n    this.overlayPositioning = \"absolute\";\n    this.placement = \"auto\";\n    this.referenceElement = undefined;\n    this.effectiveReferenceElement = undefined;\n    this.floatingLayout = \"vertical\";\n  }\n  offsetDistanceOffsetHandler() {\n    this.reposition(true);\n  }\n  offsetSkiddingHandler() {\n    this.reposition(true);\n  }\n  openHandler(value) {\n    if (value) {\n      this.reposition(true);\n    }\n  }\n  overlayPositioningHandler() {\n    this.reposition(true);\n  }\n  placementHandler() {\n    this.reposition(true);\n  }\n  referenceElementHandler() {\n    this.setUpReferenceElement();\n  }\n  // --------------------------------------------------------------------------\n  //\n  //  Lifecycle\n  //\n  // --------------------------------------------------------------------------\n  connectedCallback() {\n    connectOpenCloseComponent(this);\n    this.setUpReferenceElement(this.hasLoaded);\n  }\n  componentDidLoad() {\n    if (this.referenceElement && !this.effectiveReferenceElement) {\n      this.setUpReferenceElement();\n    }\n    this.reposition(true);\n    this.hasLoaded = true;\n  }\n  disconnectedCallback() {\n    this.removeReferences();\n    disconnectFloatingUI(this, this.effectiveReferenceElement, this.el);\n    disconnectOpenCloseComponent(this);\n  }\n  // --------------------------------------------------------------------------\n  //\n  //  Public Methods\n  //\n  // --------------------------------------------------------------------------\n  /**\n   * Updates the position of the component.\n   *\n   * @param delayed\n   */\n  async reposition(delayed = false) {\n    const { el, effectiveReferenceElement, placement, overlayPositioning, offsetDistance, offsetSkidding, arrowEl } = this;\n    return reposition(this, {\n      floatingEl: el,\n      referenceEl: effectiveReferenceElement,\n      overlayPositioning,\n      placement,\n      offsetDistance,\n      offsetSkidding,\n      arrowEl,\n      type: \"tooltip\"\n    }, delayed);\n  }\n  // --------------------------------------------------------------------------\n  //\n  //  Private Methods\n  //\n  // --------------------------------------------------------------------------\n  onBeforeOpen() {\n    this.calciteTooltipBeforeOpen.emit();\n  }\n  onOpen() {\n    this.calciteTooltipOpen.emit();\n  }\n  onBeforeClose() {\n    this.calciteTooltipBeforeClose.emit();\n  }\n  onClose() {\n    this.calciteTooltipClose.emit();\n  }\n  // --------------------------------------------------------------------------\n  //\n  //  Render Methods\n  //\n  // --------------------------------------------------------------------------\n  render() {\n    const { effectiveReferenceElement, label, open, floatingLayout } = this;\n    const displayed = effectiveReferenceElement && open;\n    const hidden = !displayed;\n    return (h(Host, { \"aria-hidden\": toAriaBoolean(hidden), \"aria-label\": label, \"aria-live\": \"polite\", \"calcite-hydrated-hidden\": hidden, id: this.getId(), role: \"tooltip\" }, h(\"div\", { class: {\n        [FloatingCSS.animation]: true,\n        [FloatingCSS.animationActive]: displayed\n      },\n      // eslint-disable-next-line react/jsx-sort-props\n      ref: this.setTransitionEl }, h(FloatingArrow, { floatingLayout: floatingLayout,\n      // eslint-disable-next-line react/jsx-sort-props\n      ref: (arrowEl) => (this.arrowEl = arrowEl) }), h(\"div\", { class: CSS.container }, h(\"slot\", null)))));\n  }\n  get el() { return this; }\n  static get watchers() { return {\n    \"offsetDistance\": [\"offsetDistanceOffsetHandler\"],\n    \"offsetSkidding\": [\"offsetSkiddingHandler\"],\n    \"open\": [\"openHandler\"],\n    \"overlayPositioning\": [\"overlayPositioningHandler\"],\n    \"placement\": [\"placementHandler\"],\n    \"referenceElement\": [\"referenceElementHandler\"]\n  }; }\n  static get style() { return tooltipCss; }\n}, [1, \"calcite-tooltip\", {\n    \"closeOnClick\": [516, \"close-on-click\"],\n    \"label\": [1],\n    \"offsetDistance\": [514, \"offset-distance\"],\n    \"offsetSkidding\": [514, \"offset-skidding\"],\n    \"open\": [516],\n    \"overlayPositioning\": [513, \"overlay-positioning\"],\n    \"placement\": [513],\n    \"referenceElement\": [1, \"reference-element\"],\n    \"effectiveReferenceElement\": [32],\n    \"floatingLayout\": [32],\n    \"reposition\": [64]\n  }]);\nfunction defineCustomElement() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"calcite-tooltip\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"calcite-tooltip\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, Tooltip);\n      }\n      break;\n  } });\n}\ndefineCustomElement();\n\nexport { Tooltip as T, defineCustomElement as d };\n"],"names":["$gSie2","parcelRequire","$b47fc600190fa4f9$var$getAlignment","placement","split","$b47fc600190fa4f9$var$getLengthFromAxis","axis","$b47fc600190fa4f9$var$getSide","$b47fc600190fa4f9$var$getMainAxisFromPlacement","includes","$b47fc600190fa4f9$var$computeCoordsFromPlacement","_ref","rtl","reference","floating","commonX","x","width","commonY","y","height","mainAxis","length","commonAlign","isVertical","coords","$b47fc600190fa4f9$var$evaluate","value","param","$b47fc600190fa4f9$var$getSideObjectFromPadding","padding","top","right","bottom","left","$b47fc600190fa4f9$var$expandPaddingObject","$b47fc600190fa4f9$var$rectToClientRect","rect","async","$b47fc600190fa4f9$var$detectOverflow","state","options","_await$platform$isEle","platform","rects","elements","strategy","boundary","rootBoundary","elementContext","altBoundary","paddingObject","element","clippingClientRect","getClippingRect","isElement","contextElement","getDocumentElement","offsetParent","getOffsetParent","offsetScale","getScale","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","$b47fc600190fa4f9$var$min$1","Math","min","$b47fc600190fa4f9$var$max$1","max","$b47fc600190fa4f9$var$within","min$1$1","max$1$1","$b47fc600190fa4f9$var$sides","$b47fc600190fa4f9$var$allPlacements","reduce","acc","side","concat","$b47fc600190fa4f9$var$oppositeSideMap","$b47fc600190fa4f9$var$getOppositePlacement","replace","$b47fc600190fa4f9$var$getAlignmentSides","alignment","mainAlignmentSide","main","cross","$b47fc600190fa4f9$var$oppositeAlignmentMap","start","end","$b47fc600190fa4f9$var$getOppositeAlignmentPlacement","$b47fc600190fa4f9$var$autoPlacement","name","_middlewareData$autoP","_middlewareData$autoP2","_placementsThatFitOnE","middlewareData","crossAxis","allowedPlacements","autoAlignment","detectOverflowOptions","placements","undefined","filter","$b47fc600190fa4f9$var$getPlacementList","overflow","currentIndex","autoPlacement","index","currentPlacement","isRTL","reset","currentOverflows","allOverflows","overflows","nextPlacement","data","placementsSortedByMostSpace","map","d","slice","v","sort","a","b","resetPlacement","every","$b47fc600190fa4f9$var$flip","_middlewareData$flip","initialPlacement","checkMainAxis","checkCrossAxis","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","flipAlignment","isBasePlacement","oppositePlacement","$b47fc600190fa4f9$var$getExpandedPlacements","push","direction","list","isStart","lr","rl","tb","bt","$b47fc600190fa4f9$var$getSideList","$b47fc600190fa4f9$var$getOppositeAxisPlacements","overflowsData","flip","_middlewareData$flip2","_overflowsData$filter","nextIndex","_overflowsData$map$so","placement1","$b47fc600190fa4f9$var$getSideOffsets","$b47fc600190fa4f9$var$isAnySideFullyClipped","some","$b47fc600190fa4f9$var$hide","offsets","referenceHiddenOffsets","referenceHidden","offsets1","escapedOffsets","escaped","$b47fc600190fa4f9$var$offset","diffCoords","mainAxisMulti","crossAxisMulti","rawValue","alignmentAxis","$b47fc600190fa4f9$var$convertValueToCoords","$b47fc600190fa4f9$var$getWindow","node","_node$ownerDocument","ownerDocument","defaultView","window","$b47fc600190fa4f9$var$getComputedStyle$1","getComputedStyle","$b47fc600190fa4f9$var$isNode","Node","$b47fc600190fa4f9$var$getNodeName","nodeName","toLowerCase","$b47fc600190fa4f9$var$isHTMLElement","HTMLElement","$b47fc600190fa4f9$var$isElement","Element","$b47fc600190fa4f9$var$isShadowRoot","ShadowRoot","$b47fc600190fa4f9$var$isOverflowElement","overflowX","overflowY","display","test","$b47fc600190fa4f9$var$isTableElement","$b47fc600190fa4f9$var$isContainingBlock","safari","$b47fc600190fa4f9$var$isSafari","css","transform","perspective","backdropFilter","willChange","contain","CSS","supports","$b47fc600190fa4f9$var$isLastTraversableNode","$b47fc600190fa4f9$var$min","$b47fc600190fa4f9$var$max","$b47fc600190fa4f9$var$round","round","$b47fc600190fa4f9$var$floor","floor","$b47fc600190fa4f9$var$createEmptyCoords","$b47fc600190fa4f9$var$getCssDimensions","parseFloat","hasOffset","offsetWidth","offsetHeight","shouldFallback","$","$b47fc600190fa4f9$var$unwrapElement","$b47fc600190fa4f9$var$getScale","domElement","getBoundingClientRect","Number","isFinite","$b47fc600190fa4f9$var$noOffsets","$b47fc600190fa4f9$var$getVisualOffsets","isFixed","floatingOffsetParent","_win$visualViewport","_win$visualViewport2","win","visualViewport","offsetLeft","offsetTop","$b47fc600190fa4f9$var$getBoundingClientRect","includeScale","isFixedStrategy","clientRect","scale","visualOffsets","offsetWin","currentIFrame","frameElement","iframeScale","iframeRect","clientLeft","paddingLeft","clientTop","paddingTop","$b47fc600190fa4f9$var$getDocumentElement","document","documentElement","$b47fc600190fa4f9$var$getNodeScroll","scrollLeft","scrollTop","pageXOffset","pageYOffset","$b47fc600190fa4f9$var$getWindowScrollBarX","$b47fc600190fa4f9$var$getParentNode","result","assignedSlot","parentNode","host","$b47fc600190fa4f9$var$getNearestOverflowAncestor","body","$b47fc600190fa4f9$var$getOverflowAncestors","scrollableAncestor","isBody","$b47fc600190fa4f9$var$getClientRectFromClippingAncestor","clippingAncestor","html","clientWidth","clientHeight","visualViewportBased","$b47fc600190fa4f9$var$getViewportRect","scroll","scrollWidth","scrollHeight","$b47fc600190fa4f9$var$getDocumentRect","$b47fc600190fa4f9$var$getInnerBoundingClientRect","$b47fc600190fa4f9$var$hasFixedPositionAncestor","stopNode","position","$b47fc600190fa4f9$var$getTrueOffsetParent","polyfill","$b47fc600190fa4f9$var$getOffsetParent","window1","currentNode","$b47fc600190fa4f9$var$getContainingBlock","$b47fc600190fa4f9$var$getRectRelativeToOffsetParent","isOffsetParentAnElement","offsetRect","$b47fc600190fa4f9$var$platform","elementClippingAncestors","cache","cachedResult","get","el","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","set","$b47fc600190fa4f9$var$getClippingElementAncestors","this","_c","clippingAncestors","firstClippingAncestor","clippingRect","accRect","getOffsetParentFn","getDimensionsFn","getDimensions","getClientRects","Array","from","$b47fc600190fa4f9$var$autoUpdate","update","ancestorScroll","ancestorResize","elementResize","layoutShift","IntersectionObserver","animationFrame","referenceEl","ancestors","forEach","addEventListener","passive","cleanupIo","onMove","timeoutId","io","root","cleanup","clearTimeout","disconnect","refresh","skip","threshold","insetTop","insetRight","insetBottom","insetLeft","isFirstUpdate","entries","ratio","intersectionRatio","setTimeout","observe","$b47fc600190fa4f9$var$observeMove","frameId","resizeObserver","ResizeObserver","prevRefRect","frameLoop","nextRefRect","requestAnimationFrame","removeEventListener","cancelAnimationFrame","$b47fc600190fa4f9$var$computePosition","Map","mergedOptions","platformWithCache","config","middleware","validMiddleware","Boolean","getElementRects","statefulPlacement","resetCount","i","fn","nextX","nextY","$b47fc600190fa4f9$var$computePosition$1","$b47fc600190fa4f9$var$config","floatingUINonChromiumPositioningFix","globalThis","$b47fc600190fa4f9$var$floatingUIBrowserCheck","Build","isBrowser","$eXEar","g","uaData","brands","find","brand","version","navigator","userAgent","ua","browser","parseInt","$b47fc600190fa4f9$var$isChrome109OrAbove","originalGetOffsetParent","$b47fc600190fa4f9$var$patchFloatingUiForNonChromiumBrowsers","$b47fc600190fa4f9$var$positionFloatingUI","component","floatingEl","overlayPositioning","flipDisabled","flipPlacements","offsetDistance","offsetSkidding","arrowEl","type","effectivePlacement","$b47fc600190fa4f9$var$getEffectivePlacement","$b47fc600190fa4f9$var$getMiddleware","arrow","x1","y1","$b47fc600190fa4f9$var$ARROW_CSS_TRANSFORM","floatingLayout","Object","assign","style","hide","visibility","pointerEvents","setAttribute","$b47fc600190fa4f9$var$placementDataAttribute","transform1","$b47fc600190fa4f9$var$repositionDebounceTimeout","$b47fc600190fa4f9$var$effectivePlacements","$b47fc600190fa4f9$export$d66501df72047452","animation","animationActive","defaultMiddleware","limiter","mainAxisCoord","crossAxisCoord","maxSide","maxSide1","limitedCoords","arrowDimensions","isYAxis","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","maxPadding","center","offset","alignmentOffset","centerOffset","$b47fc600190fa4f9$var$arrow","$b47fc600190fa4f9$export$2d1720544b23b823","filteredPlacements","console","warn","tagName","join","trim","$2JtiB","c","reverse","$b47fc600190fa4f9$export$43caf9889c228507","delayed","open","positionFunction","debounced","$b47fc600190fa4f9$var$componentToDebouncedRepositionMap","$2VrTI","leading","maxWait","$b47fc600190fa4f9$var$getDebouncedReposition","$b47fc600190fa4f9$var$cleanupMap","WeakMap","$b47fc600190fa4f9$export$db3b6bfb95261072","$b47fc600190fa4f9$export$407448d2b89b1813","runAutoUpdate","_refEl","_floatingEl","updateCallback","reposition","delete","cancel","$b47fc600190fa4f9$export$8b22cf2602fb60ce","ceil","hypot","module","exports","import","resolve","then","$ef7689007096c8a0$export$6503ec6e8aabbaf","$ef7689007096c8a0$export$f7ad0328861e2f03","$ef7689007096c8a0$var$mapping","pairs","keys","id","resolved","Error","$3e89cc6779e1df06$var$componentToTransitionListeners","$3e89cc6779e1df06$var$transitionStart","event","propertyName","openTransitionProp","target","transitionEl","onBeforeOpen","onBeforeClose","$3e89cc6779e1df06$var$transitionEnd","onOpen","onClose","$3e89cc6779e1df06$export$db3b6bfb95261072","$3e89cc6779e1df06$export$4368d992c4eafac0","boundOnTransitionStart","bind","boundOnTransitionEnd","has","$5da52a2edcc0de38$var$CSS","$5da52a2edcc0de38$var$DEFAULTS","strokeWidth","$5da52a2edcc0de38$export$d66501df72047452","key","ref","svgX","dValue","h","class","viewBox","fill","stroke","$cc0433c867173662$var$CSS","$cc0433c867173662$var$ARIA_DESCRIBED_BY","$cc0433c867173662$var$getEffectiveReferenceElement","tooltip","referenceElement","u","$cc0433c867173662$var$manager","registerElement","registeredElementCount","registeredElements","shadowRoot","getReferenceElShadowRootNode","registerShadowRoot","addListeners","unregisterElement","unregisterShadowRoot","removeListeners","addShadowListeners","focusInHandler","capture","focusOutHandler","removeShadowListeners","keyDownHandler","pointerMoveHandler","pointerDownHandler","clearHoverOpenTimeout","hoverOpenTimeout","clearHoverCloseTimeout","hoverCloseTimeout","clearHoverTimeout","closeActiveTooltip","activeTooltip","toggleTooltip","toggleFocusedTooltip","queryFocusedTooltip","queryTooltip","composedPath","isClosableClickedTooltip","closeOnClick","clickedTooltip","registeredShadowRootCounts","newCount","constructor","hoveredTooltip","registeredElement","pathEl","defaultPrevented","contains","preventDefault","openHoveredTooltip","closeHoveredTooltip","j","$cc0433c867173662$export$971d5caa766a69d7","proxyCustomElement","offsetDistanceOffsetHandler","offsetSkiddingHandler","openHandler","overlayPositioningHandler","placementHandler","referenceElementHandler","setUpReferenceElement","connectedCallback","$5mTah","hasLoaded","componentDidLoad","effectiveReferenceElement","disconnectedCallback","removeReferences","$fuN8z","r","calciteTooltipBeforeOpen","emit","calciteTooltipOpen","calciteTooltipBeforeClose","calciteTooltipClose","render","label","displayed","hidden","Host","t","getId","role","F","setTransitionEl","$82tcM","watchers","super","__registerHost","__attachShadow","createEvent","guid","$5nUIg","addReferences","removeAttribute","$cc0433c867173662$export$4368d992c4eafac0","customElements","define"],"version":3,"file":"calcite-flow-item.9a63e17c.js.map"}