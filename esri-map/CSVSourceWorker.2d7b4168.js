var e=("undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{}).parcelRequire594f;e.register("kcdKc",(function(t,i){var s,r,a,n;s=t.exports,r="QueryEngine",a=function(){return M},Object.defineProperty(s,r,{get:a,set:n,enumerable:!0,configurable:!0});var u=e("aX9sh"),o=e("bPmsI"),c=e("itGIg"),l=e("1CpCt"),h=e("4B4sQ"),d=e("zPXCh"),y=e("ccOFp"),f=e("19dbe"),p=e("772GK"),m=e("86d4E"),g=e("hq5aB"),_=e("fau59"),S=e("8RZNq"),x=e("7CVm9"),w=e("haPYR"),R=e("11H8e"),Q=e("a9gdw"),E=e("hOW65"),F=e("UbUrW"),I=e("4JNri"),T=e("38xmB"),b=e("QiKdE"),A=e("cM1Gj");const N="feature-store:unsupported-query";const v=new(0,h.MemCacheStorage)(2e6);let j=0;class M{destroy(){this._frameTask=(0,l.removeMaybe)(this._frameTask),this.clearCache(),(0,l.destroyMaybe)(this._geometryQueryCache),this._changeHandle=(0,l.removeMaybe)(this._changeHandle),(0,l.destroyMaybe)(this.fieldsIndex)}get featureAdapter(){return this.featureStore.featureAdapter}get fullExtent(){const e=this.featureStore.fullBounds;return(0,l.isNone)(e)?null:{xmin:e[0],ymin:e[1],xmax:e[2],ymax:e[3],spatialReference:(0,I.cleanFromGeometryEngine)(this.spatialReference)}}get timeExtent(){return this.timeInfo?(this._timeExtent||(this._timeExtent=(0,F.getTimeExtent)(this.timeInfo,this.featureStore)),this._timeExtent):null}clearCache(){this._geometryQueryCache?.clear(),this._allItems=null,this._timeExtent=null}async executeQuery(e,t){try{return(await this._executeQuery(e,{},t)).createQueryResponse()}catch(t){if(t!==I.QUERY_ENGINE_EMPTY_RESULT)throw t;return new(0,Q.QueryEngineResult)([],e,this).createQueryResponse()}}async executeQueryForCount(e={},t){try{return(await this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null},t)).createQueryResponseForCount()}catch(e){if(e!==I.QUERY_ENGINE_EMPTY_RESULT)throw e;return 0}}async executeQueryForExtent(e,t){const i=e.outSR;try{const s=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},t),r=s.size;if(!r)return{count:0,extent:null};(0,y.set)(q,y.NEGATIVE_INFINITY),this.featureStore.forEachBounds(s.items,(e=>(0,y.expandWithAABB)(q,e)),P);const a={xmin:q[0],ymin:q[1],xmax:q[3],ymax:q[4],spatialReference:(0,I.cleanFromGeometryEngine)(this.spatialReference)};this.hasZ&&isFinite(q[2])&&isFinite(q[5])&&(a.zmin=q[2],a.zmax=q[5]);const n=(0,w.project)(a,s.spatialReference,i);if(n.spatialReference=(0,I.cleanFromGeometryEngine)(i||this.spatialReference),n.xmax-n.xmin==0){const e=(0,d.getMetersPerUnitForSR)(n.spatialReference);n.xmin-=e,n.xmax+=e}if(n.ymax-n.ymin==0){const e=(0,d.getMetersPerUnitForSR)(n.spatialReference);n.ymin-=e,n.ymax+=e}if(this.hasZ&&null!=n.zmin&&null!=n.zmax&&n.zmax-n.zmin==0){const e=(0,d.getMetersPerUnitForSR)(n.spatialReference);n.zmin-=e,n.zmax+=e}return{count:r,extent:n}}catch(e){if(e===I.QUERY_ENGINE_EMPTY_RESULT)return{count:0,extent:null};throw e}}async executeQueryForIds(e,t){return this.executeQueryForIdSet(e,t).then((e=>Array.from(e)))}async executeQueryForIdSet(e,t){try{const i=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},t),s=i.items,r=new Set;return await this._reschedule((()=>{for(const e of s)r.add(i.featureAdapter.getObjectId(e))}),t),r}catch(e){if(e===I.QUERY_ENGINE_EMPTY_RESULT)return new Set;throw e}}async executeQueryForSnapping(e,t){const{point:i,distance:s,types:r}=e;if(r===Q.SnappingTypes.NONE)return{candidates:[]};const a=await this._reschedule((()=>this._checkQuerySupport(e.query)),t),n=!(0,_.equals)(i.spatialReference,this.spatialReference);n&&await(0,w.checkProjectionSupport)(i.spatialReference,this.spatialReference);const u="number"==typeof s?s:s.x,o="number"==typeof s?s:s.y,c={xmin:i.x-u,xmax:i.x+u,ymin:i.y-o,ymax:i.y+o,spatialReference:i.spatialReference},h=n?(0,w.project)(c,this.spatialReference):c;if(!h)return{candidates:[]};const d=(await(0,g.normalizeCentralMeridian)((0,m.fromJSON)(i),null,{signal:t}))[0],y=(await(0,g.normalizeCentralMeridian)((0,m.fromJSON)(h),null,{signal:t}))[0];if((0,l.isNone)(d)||(0,l.isNone)(y))return{candidates:[]};const f=new(0,Q.QueryEngineResult)(this._searchFeatures(this._getQueryBBoxes(y.toJSON())),a,this);await this._reschedule((()=>this._executeObjectIdsQuery(f)),t),await this._reschedule((()=>this._executeTimeQuery(f)),t),await this._reschedule((()=>this._executeAttributesQuery(f)),t);const p=d.toJSON(),S=n?(0,w.project)(p,this.spatialReference):p,x=n?Math.max(h.xmax-h.xmin,h.ymax-h.ymin)/2:s;return f.createSnappingResponse({...e,point:S,distance:x},i.spatialReference)}async executeQueryForLatestObservations(e,t){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new(0,o.default)(N,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});try{const i=await this._executeQuery(e,{},t);return await this._reschedule((()=>this._filterLatest(i)),t),i.createQueryResponse()}catch(t){if(t!==I.QUERY_ENGINE_EMPTY_RESULT)throw t;return new(0,Q.QueryEngineResult)([],e,this).createQueryResponse()}}async executeQueryForSummaryStatistics(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createSummaryStatisticsResponse(t)}async executeQueryForUniqueValues(e={},t,i){const{field:s,valueExpression:r}=t;return(await this._getQueryEngineResultForStats(e,{field:s,valueExpression:r},i)).createUniqueValuesResponse(t)}async executeQueryForClassBreaks(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createClassBreaksResponse(t)}async executeQueryForHistogram(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createHistogramResponse(t)}async _schedule(e,t){return(0,l.isSome)(this._frameTask)?this._frameTask.schedule(e,t):e(A.noBudget)}async _reschedule(e,t){return(0,l.isSome)(this._frameTask)?this._frameTask.reschedule(e,t):e(A.noBudget)}_getAll(e){return(0,l.isNone)(this._allItems)&&(this._allItems=this.featureStore.toArray()),new(0,Q.QueryEngineResult)(this._allItems,e,this)}async _executeQuery(e,t,i){e=(0,c.clone)(e),e=await this._schedule((()=>(0,I.normalizeQuery)(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>this._checkQuerySupport(e)),i),e={...e,...t};const s=await this._reschedule((()=>this._executeSceneFilterQuery(e,i)),i),r=await this._reschedule((()=>this._executeGeometryQuery(e,s,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(r)),i),await this._reschedule((()=>this._executeObjectIdsQuery(r)),i),await this._reschedule((()=>this._executeTimeQuery(r)),i),await this._reschedule((()=>this._executeAttributesQuery(r)),i),r}async _executeSceneFilterQuery(e,t){if((0,l.isNone)(e.sceneFilter))return null;const{outSR:i,returnGeometry:s,returnCentroid:r}=e,a=this.featureStore.featureSpatialReference,n=e.sceneFilter.geometry,u=(0,l.isNone)(a)||(0,_.equals)(a,n.spatialReference)?n:(0,w.project)(n,a);if(!u)return null;const o=s||r,c=(0,_.isValid)(i)&&!(0,_.equals)(this.spatialReference,i)&&o?async e=>this._project(e,i):e=>e,h=this.featureAdapter,d=this._searchFeatures(this._getQueryBBoxes(u));if("disjoint"===e.sceneFilter.spatialRelationship){if(!d.length)return null;const i=new Set;for(const e of d)i.add(h.getObjectId(e));const s=await this._reschedule((()=>this.featureStore.toArray()),t),r=await this._reschedule((async()=>{const r=await(0,E.getSpatialQueryOperator)("esriSpatialRelDisjoint",u,this.geometryType,this.hasZ,this.hasM),a=await this._runSpatialFilter(s,(e=>!i.has(h.getObjectId(e))||r(h.getGeometry(e))),t);return new(0,Q.QueryEngineResult)(a,e,this)}),t);return c(r)}if(!d.length)return new(0,Q.QueryEngineResult)([],e,this);if(this._canExecuteSinglePass(u,e))return c(new(0,Q.QueryEngineResult)(d,e,this));const y=await(0,E.getSpatialQueryOperator)("esriSpatialRelContains",u,this.geometryType,this.hasZ,this.hasM),f=await this._runSpatialFilter(d,(e=>y(h.getGeometry(e))),t);return c(new(0,Q.QueryEngineResult)(f,e,this))}async _executeGeometryQuery(e,t,i){if((0,l.isSome)(t)&&0===t.items.length)return t;e=(0,l.isSome)(t)?t.query:e;const{geometry:s,outSR:r,spatialRel:a,returnGeometry:n,returnCentroid:o}=e,c=this.featureStore.featureSpatialReference,h=!s||(0,l.isNone)(c)||(0,_.equals)(c,s.spatialReference)?s:(0,w.project)(s,c),d=n||o,y=(0,_.isValid)(r)&&!(0,_.equals)(this.spatialReference,r),f=this._geometryQueryCache&&(0,l.isNone)(t)?y&&d?JSON.stringify({originalFilterGeometry:s,spatialRelationship:a,outSpatialReference:r}):JSON.stringify({originalFilterGeometry:s,spatialRelationship:a}):null,p=f?this._geometryQueryCache.get(f):null;if((0,l.isSome)(p))return new(0,Q.QueryEngineResult)(p,e,this);const m=async e=>(y&&d&&await this._project(e,r),f&&this._geometryQueryCache.put(f,e.items,e.items.length+1),e);if(!h)return m((0,l.isSome)(t)?t:this._getAll(e));const g=this.featureAdapter;let S=this._searchFeatures(this._getQueryBBoxes(s));if("esriSpatialRelDisjoint"===a){if(!S.length)return m((0,l.isSome)(t)?t:this._getAll(e));const s=new Set;for(const e of S)s.add(g.getObjectId(e));const r=(0,l.isSome)(t)?t.items:await this._reschedule((()=>this.featureStore.toArray()),i),n=await this._reschedule((async()=>{const t=await(0,E.getSpatialQueryOperator)(a,h,this.geometryType,this.hasZ,this.hasM),n=await this._runSpatialFilter(r,(e=>!s.has(g.getObjectId(e))||t(g.getGeometry(e))),i);return new(0,Q.QueryEngineResult)(n,e,this)}),i);return m(n)}if((0,l.isSome)(t)){const e=new(0,u.PositionHint);S=S.filter((i=>(0,u.indexOf)(t.items,i,t.items.length,e)>=0))}if(!S.length){const t=new(0,Q.QueryEngineResult)([],e,this);return f&&this._geometryQueryCache.put(f,t.items,1),t}if(this._canExecuteSinglePass(h,e))return m(new(0,Q.QueryEngineResult)(S,e,this));const x=await(0,E.getSpatialQueryOperator)(a,h,this.geometryType,this.hasZ,this.hasM),R=await this._runSpatialFilter(S,(e=>x(g.getGeometry(e))),i);return m(new(0,Q.QueryEngineResult)(R,e,this))}_executeAggregateIdsQuery(e){if(0===e.items.length||!e.query.aggregateIds||!e.query.aggregateIds.length||(0,l.isNone)(this.aggregateAdapter))return;const t=new Set;for(const i of e.query.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(i).forEach((e=>t.add(e)));const i=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>t.has(i(e))))}_executeObjectIdsQuery(e){if(0===e.items.length||!e.query.objectIds||!e.query.objectIds.length)return;const t=new Set(e.query.objectIds),i=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>t.has(i(e))))}_executeTimeQuery(e){if(0===e.items.length)return;const t=(0,F.getTimeOperator)(this.timeInfo,e.query.timeExtent,this.featureAdapter);(0,l.isNone)(t)||(e.items=e.items.filter(t))}_executeAttributesQuery(e){if(0===e.items.length)return;const t=(0,x.getWhereClause)(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter((e=>t.testFeature(e,this.featureAdapter)))}}async _runSpatialFilter(e,t,i){if(!t)return e;if((0,l.isNone)(this._frameTask))return e.filter((e=>t(e)));let s=0;const r=new Array,a=async n=>{for(;s<e.length;){const u=e[s++];t(u)&&(r.push(u),n.madeProgress()),n.done&&await this._reschedule((e=>a(e)),i)}};return this._reschedule((e=>a(e)),i).then((()=>r))}_filterLatest(e){const{trackIdField:t,startTimeField:i,endTimeField:s}=this.timeInfo,r=s||i,a=new Map,n=this.featureAdapter.getAttribute;for(const i of e.items){const e=n(i,t),s=n(i,r),u=a.get(e);(!u||s>n(u,r))&&a.set(e,i)}e.items=Array.from(a.values())}_canExecuteSinglePass(e,t){const{spatialRel:i}=t;return(0,E.canQueryWithRBush)(e)&&("esriSpatialRelEnvelopeIntersects"===i||"esriGeometryPoint"===this.geometryType&&("esriSpatialRelIntersects"===i||"esriSpatialRelContains"===i||"esriSpatialRelWithin"===i))}async _project(e,t){if(!t||(0,_.equals)(this.spatialReference,t))return e;const i=this.featureAdapter,s=await(0,w.projectMany)(e.items.map((e=>(0,I.getGeometry)(this.geometryType,this.hasZ,this.hasM,i.getGeometry(e)))),this.spatialReference,t);return e.items=s.map(((t,s)=>i.cloneWithGeometry(e.items[s],(0,S.convertFromGeometry)(t,this.hasZ,this.hasM)))),e}_getQueryBBoxes(e){if((0,E.canQueryWithRBush)(e)){if((0,m.isExtent)(e))return[(0,f.fromValues)(e.xmin,e.ymin,e.xmax,e.ymax)];if((0,m.isPolygon)(e))return e.rings.map((e=>(0,f.fromValues)(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1]))))}return[(0,p.getBoundsXY)((0,f.create)(),e)]}_searchFeatures(e){for(const t of e)this.featureStore.forEachInBounds(t,(e=>C.add(e)));const t=Array.from(C.values());return C.clear(),t}async _checkStatisticsSupport(e,t){if(e.distance<0||null!=e.geometryPrecision||e.multipatchOption||e.pixelSize||e.relationParam||e.text||e.outStatistics||e.groupByFieldsForStatistics||e.having||e.orderByFields)throw new(0,o.default)(N,"Unsupported query options",{query:e});return this._checkAttributesQuerySupport(e),Promise.all([this._checkStatisticsParamsSupport(t),(0,E.checkSpatialQuerySupport)(e,this.geometryType,this.spatialReference),(0,w.checkProjectionSupport)(this.spatialReference,e.outSR)]).then((()=>e))}async _checkStatisticsParamsSupport(e){let t=[];if(e.valueExpression){const{arcadeUtils:i}=await(0,b.loadArcade)();t=i.extractFieldNames(e.valueExpression)}if(e.field&&t.push(e.field),e.normalizationField&&t.push(e.normalizationField),!t.length)throw new(0,o.default)(N,"params should have at least a field or valueExpression",{params:e});(0,x.validateFields)(this.fieldsIndex,t,"params contains missing fields")}async _checkQuerySupport(e){if(e.distance<0||null!=e.geometryPrecision||e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new(0,o.default)(N,"Unsupported query options",{query:e});return this._checkAttributesQuerySupport(e),this._checkStatisticsQuerySupport(e),Promise.all([(0,E.checkSpatialQuerySupport)(e,this.geometryType,this.spatialReference),(0,w.checkProjectionSupport)(this.spatialReference,e.outSR)]).then((()=>e))}_checkAttributesQuerySupport(e){const{outFields:t,orderByFields:i,returnDistinctValues:s,outStatistics:r}=e,a=r?r.map((e=>e.outStatisticFieldName&&e.outStatisticFieldName.toLowerCase())).filter(Boolean):[];if(i&&i.length>0){const e=" asc",t=" desc",s=i.map((i=>{const s=i.toLowerCase();return s.includes(e)?s.split(e)[0]:s.includes(t)?s.split(t)[0]:i})).filter((e=>!a.includes(e)));(0,x.validateFields)(this.fieldsIndex,s,"orderByFields contains missing fields")}if(t&&t.length>0)(0,x.validateFields)(this.fieldsIndex,t,"outFields contains missing fields");else if(s)throw new(0,o.default)(N,"outFields should be specified for returnDistinctValues",{query:e});(0,x.validateWhere)(this.fieldsIndex,e.where)}_checkStatisticsQuerySupport(e){const{outStatistics:t,groupByFieldsForStatistics:i,having:s}=e,r=i&&i.length,a=t&&t.length;if(s){if(!r||!a)throw new(0,o.default)(N,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:e});(0,x.validateHaving)(this.fieldsIndex,s,t)}if(a){if(!function(e){return e.every((e=>"exceedslimit"!==e.statisticType))}(t))return;const s=t.map((e=>e.onStatisticField)).filter(Boolean);(0,x.validateFields)(this.fieldsIndex,s,"onStatisticFields contains missing fields"),r&&(0,x.validateFields)(this.fieldsIndex,i,"groupByFieldsForStatistics contains missing fields");for(const i of t){const{onStatisticField:t,statisticType:s}=i;if("percentile_disc"!==s&&"percentile_cont"!==s||!("statisticParameters"in i)){if("count"!==s&&t&&(0,x.hasInvalidFieldType)(t,this.fieldsIndex))throw new(0,o.default)(N,"outStatistics contains non-numeric fields",{definition:i,query:e})}else{const{statisticParameters:t}=i;if(!t)throw new(0,o.default)(N,"statisticParamters should be set for percentile type",{definition:i,query:e})}}}}async _getQueryEngineResultForStats(e,t,i){e=(0,c.clone)(e);try{e=await this._schedule((()=>(0,I.normalizeQuery)(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>this._checkStatisticsSupport(e,t)),i);const s=await this._reschedule((()=>this._executeSceneFilterQuery(e,i)),i),r=await this._reschedule((()=>this._executeGeometryQuery(e,s,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(r)),i),await this._reschedule((()=>this._executeObjectIdsQuery(r)),i),await this._reschedule((()=>this._executeTimeQuery(r)),i),await this._reschedule((()=>this._executeAttributesQuery(r)),i),r}catch(t){if(t!==I.QUERY_ENGINE_EMPTY_RESULT)throw t;return new(0,Q.QueryEngineResult)([],e,this)}}constructor(e){this.capabilities={query:R.queryCapabilities},this.geometryType=e.geometryType,this.hasM=e.hasM,this.hasZ=e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",(()=>this.clearCache())),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new(0,h.MemCache)(j+++"$$",v)),this.fieldsIndex=new(0,T.default)(e.fields),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}}const P=(0,y.create)(),q=(0,y.create)(),C=new Set}));
//# sourceMappingURL=CSVSourceWorker.2d7b4168.js.map
